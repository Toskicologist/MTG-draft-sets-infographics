<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MTG Card Knowledge Quiz - Custom Mode</title>
  <style>
    /* ===== Base / Reset ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f0f13;
      --surface: #1a1a24;
      --surface-hover: #222233;
      --border: #2a2a3a;
      --text: #e0e0e8;
      --text-muted: #8888aa;
      --accent: #6c63ff;
      --accent-hover: #7f78ff;
      --correct: #22c55e;
      --correct-bg: rgba(34,197,94,0.12);
      --wrong: #ef4444;
      --wrong-bg: rgba(239,68,68,0.12);
      --gold: #f59e0b;
      --white-mana: #f9faf4;
      --blue-mana: #0e68ab;
      --black-mana: #150b00;
      --red-mana: #d3202a;
      --green-mana: #00733e;
      --colorless-mana: #9ea0a1;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }

    /* ===== Layout ===== */
    .app-container {
      max-width: 720px;
      margin: 0 auto;
      padding: 16px;
    }

    /* ===== Header ===== */
    .header {
      text-align: center;
      padding: 24px 0 16px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 20px;
    }
    .header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .header .subtitle {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-top: 4px;
    }
    .header .api-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      background: rgba(108,99,255,0.15);
      color: #9b94ff;
      margin-top: 6px;
    }

    /* ===== Score Bar ===== */
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 18px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 8px;
    }
    .score-item {
      text-align: center;
    }
    .score-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .score-value {
      font-size: 1.2rem;
      font-weight: 700;
    }
    .score-value.streak { color: var(--gold); }
    .score-value.accuracy { color: var(--accent); }

    /* ===== Filters ===== */
    .filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .filter-select {
      flex: 1;
      min-width: 120px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238888aa' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }
    .filter-select:hover { border-color: var(--accent); }

    /* ===== Preset Toggle Bar ===== */
    .preset-toggle-bar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .preset-primary {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      flex: 1;
    }

    .preset-btn {
      padding: 8px 16px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .preset-btn:hover:not(.active):not(:disabled) {
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .preset-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .preset-btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .preset-btn.loading {
      position: relative;
    }

    .spinner-mini {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    .preset-more {
      position: relative;
    }

    .preset-more-btn {
      padding: 8px 14px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text-muted);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .preset-more-btn:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .preset-secondary {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 180px;
      z-index: 10;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .preset-secondary .preset-btn {
      width: 100%;
      justify-content: flex-start;
    }

    @media (max-width: 600px) {
      .preset-primary {
        width: 100%;
      }

      .preset-btn {
        flex: 1;
        min-width: calc(50% - 4px);
        justify-content: center;
      }
    }

    /* ===== Search Field ===== */
    .search-field-container {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .search-input {
      flex: 1;
      min-width: 300px;
      padding: 10px 14px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.9rem;
      font-family: 'Courier New', monospace;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .search-btn {
      padding: 10px 20px;
      border: 2px solid var(--accent);
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .search-btn:hover {
      background: #5850e0;
      border-color: #5850e0;
    }

    .search-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      flex-basis: 100%;
      margin-top: -4px;
    }

    .search-hint a {
      color: var(--accent);
      text-decoration: none;
    }

    .search-hint a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .search-input {
        min-width: 100%;
      }

      .search-btn {
        width: 100%;
      }
    }

    /* ===== Custom Mode Configuration Panel ===== */
    .config-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .config-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .config-header h3 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent);
    }

    .config-toggle-btn {
      padding: 6px 14px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text-muted);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .config-toggle-btn:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .field-config-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 16px;
    }

    .field-config-table th,
    .field-config-table td {
      padding: 12px 8px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .field-config-table th {
      background: rgba(108, 99, 255, 0.1);
      color: var(--accent);
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
    }

    .field-config-table input[type="checkbox"],
    .field-config-table input[type="radio"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    .field-config-table input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .difficulty-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .difficulty-0 { background: rgba(128, 128, 128, 0.2); color: #999; }
    .difficulty-1 { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .difficulty-2 { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .difficulty-3 { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
    .difficulty-4 { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .difficulty-5 { background: rgba(168, 85, 247, 0.2); color: #a855f7; }

    /* ===== Preview Panel ===== */
    .preview-panel {
      background: rgba(108, 99, 255, 0.05);
      border: 1px dashed var(--accent);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }

    .preview-panel h4 {
      color: var(--accent);
      margin-bottom: 12px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .preview-content {
      background: var(--surface);
      border-radius: 8px;
      padding: 16px;
    }

    .preview-field {
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.9rem;
    }

    .preview-field:last-child {
      border-bottom: none;
    }

    .preview-field strong {
      color: var(--accent);
      margin-right: 8px;
    }

    .preview-question {
      padding: 12px 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .preview-answer {
      padding: 8px 12px;
      background: rgba(108, 99, 255, 0.1);
      border-radius: 6px;
      font-size: 0.9rem;
      margin-top: 8px;
    }

    .preview-answer.blurred {
      filter: blur(5px);
      opacity: 0.5;
      user-select: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preview-answer.blurred:hover {
      filter: blur(0);
      opacity: 1;
    }

    .preview-error {
      color: var(--wrong);
      padding: 12px;
      text-align: center;
      font-size: 0.9rem;
    }

    .validation-messages {
      margin-top: 12px;
    }

    .validation-error,
    .validation-warning {
      padding: 10px 14px;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .validation-error {
      background: var(--wrong-bg);
      color: var(--wrong);
      border: 1px solid var(--wrong);
    }

    .validation-warning {
      background: rgba(245, 158, 11, 0.12);
      color: #f59e0b;
      border: 1px solid rgba(245, 158, 11, 0.3);
    }

    /* ===== Answer Input Variants ===== */
    .text-input-container,
    .number-input-container {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      align-items: center;
    }

    .text-input,
    .number-input {
      flex: 1;
      padding: 14px 16px;
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 1rem;
      font-family: 'Courier New', monospace;
      transition: all 0.15s;
    }

    .text-input:focus,
    .number-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.1);
    }

    .text-input:disabled,
    .number-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .submit-answer-btn {
      padding: 14px 32px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }

    .submit-answer-btn:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-2px);
    }

    .submit-answer-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .card-image-display {
      margin: 16px 0;
      text-align: center;
    }

    .card-image-display img {
      max-width: 300px;
      max-height: 400px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    @media (max-width: 600px) {
      .field-config-table {
        font-size: 0.85rem;
      }

      .field-config-table th,
      .field-config-table td {
        padding: 8px 4px;
      }

      .text-input-container,
      .number-input-container {
        flex-direction: column;
      }

      .submit-answer-btn {
        width: 100%;
      }
    }

    /* ===== Question Card ===== */
    .question-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 24px;
      margin-bottom: 16px;
    }
    .question-type-badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 12px;
    }
    .badge-mana-value { background: rgba(108,99,255,0.15); color: #9b94ff; }
    .badge-power-toughness { background: rgba(239,68,68,0.15); color: #f87171; }
    .badge-color { background: rgba(245,158,11,0.15); color: #fbbf24; }
    .badge-card-type { background: rgba(34,197,94,0.15); color: #4ade80; }
    .badge-keywords { background: rgba(168,85,247,0.15); color: #c084fc; }

    .question-text {
      font-size: 1.15rem;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .card-name-highlight {
      color: var(--accent);
    }
    .question-hint {
      font-size: 0.82rem;
      color: var(--text-muted);
      margin-bottom: 18px;
    }

    /* ===== Multiple Choice Options ===== */
    .mc-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .mc-option {
      padding: 14px 16px;
      border: 2px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      text-align: center;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mc-option:hover:not(.disabled) {
      border-color: var(--accent);
      background: var(--surface-hover);
    }
    .mc-option.selected-correct {
      border-color: var(--correct);
      background: var(--correct-bg);
      color: var(--correct);
    }
    .mc-option.selected-wrong {
      border-color: var(--wrong);
      background: var(--wrong-bg);
      color: var(--wrong);
    }
    .mc-option.reveal-correct {
      border-color: var(--correct);
      background: var(--correct-bg);
      color: var(--correct);
    }
    .mc-option.disabled {
      cursor: default;
      opacity: 0.6;
    }

    /* ===== Color Picker ===== */
    .color-picker {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .color-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 3px solid var(--border);
      cursor: pointer;
      transition: all 0.15s;
      font-weight: 700;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .color-btn:hover:not(.disabled) {
      transform: scale(1.1);
    }
    .color-btn.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108,99,255,0.3);
      transform: scale(1.1);
    }
    .color-btn.disabled { cursor: default; }
    .color-btn.W { background: var(--white-mana); color: #333; }
    .color-btn.U { background: var(--blue-mana); color: #fff; }
    .color-btn.B { background: var(--black-mana); color: #ccc; border-color: #444; }
    .color-btn.R { background: var(--red-mana); color: #fff; }
    .color-btn.G { background: var(--green-mana); color: #fff; }
    .color-btn.C { background: var(--colorless-mana); color: #333; }

    .color-submit-btn {
      display: block;
      margin: 14px auto 0;
      padding: 10px 32px;
      border: none;
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }
    .color-submit-btn:hover { background: var(--accent-hover); }
    .color-submit-btn:disabled { opacity: 0.4; cursor: default; }

    /* ===== Feedback ===== */
    .feedback-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 16px;
      text-align: center;
    }
    .feedback-result {
      font-size: 1.1rem;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .feedback-result.correct { color: var(--correct); }
    .feedback-result.wrong { color: var(--wrong); }
    .feedback-detail {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 16px;
    }
    .feedback-card-image {
      max-width: 260px;
      border-radius: 12px;
      margin: 12px auto;
      display: block;
    }
    .feedback-stats {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 12px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .next-btn {
      display: block;
      margin: 18px auto 0;
      padding: 12px 40px;
      border: none;
      border-radius: 10px;
      background: var(--accent);
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }
    .next-btn:hover { background: var(--accent-hover); }

    /* ===== Streak Animation ===== */
    .streak-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--gold);
      text-shadow: 0 0 30px rgba(245,158,11,0.5);
      pointer-events: none;
      animation: streakPop 0.8s ease-out forwards;
      z-index: 100;
    }
    @keyframes streakPop {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
      40% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
    }

    /* ===== Loading ===== */
    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }
    .loading-spinner {
      width: 36px;
      height: 36px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 12px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .refresh-btn {
      padding: 8px 20px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
      margin-top: 12px;
    }
    .refresh-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* ===== Responsive ===== */
    @media (max-width: 500px) {
      .mc-options { grid-template-columns: 1fr; }
      .score-bar { padding: 10px 12px; }
      .question-card { padding: 18px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    // ============================================================
    //  MTG Card Knowledge Quiz â€” API Version â€” v0.3.0
    //  2026-02-13  |  Claude Opus 4.6
    //
    //  Uses Scryfall API instead of embedded data
    //  Caches popular cards for better UX
    // ============================================================

    const { useState, useEffect, useCallback, useRef } = React;

    // ---- Constants ----
    const QUESTION_TYPES = ['manaValue', 'powerToughness', 'color', 'cardType', 'keywords'];

    // ---- Field Definitions ----
    const FIELD_DEFINITIONS = {
      cardName: {
        id: 'cardName',
        label: 'Card Name',
        canShow: true,
        canAsk: true,
        answerType: 'text',
        difficulty: 5,
        extractValue: (card) => card.name,
        formatDisplay: (value) => value,
        incompatibleWith: ['cardImage'],
      },
      manaValue: {
        id: 'manaValue',
        label: 'Mana Value',
        canShow: true,
        canAsk: true,
        answerType: 'number',
        difficulty: 2,
        extractValue: (card) => card.manaValue,
        formatDisplay: (value) => String(Math.floor(value)),
        incompatibleWith: ['cardImage'],
      },
      colors: {
        id: 'colors',
        label: 'Colors',
        canShow: true,
        canAsk: true,
        answerType: 'colorPicker',
        difficulty: 3,
        extractValue: (card) => card.colors,
        formatDisplay: (colors) => colors.length ? colors.join('') : 'Colorless',
        incompatibleWith: [],
      },
      typeLine: {
        id: 'typeLine',
        label: 'Type Line',
        canShow: true,
        canAsk: true,
        answerType: 'multipleChoice',
        difficulty: 3,
        extractValue: (card) => card.typeLine,
        formatDisplay: (value) => value,
        incompatibleWith: ['cardImage'],
      },
      powerToughness: {
        id: 'powerToughness',
        label: 'P/T',
        canShow: true,
        canAsk: true,
        answerType: 'multipleChoice',
        difficulty: 4,
        extractValue: (card) => card.power && card.toughness ? `${card.power}/${card.toughness}` : null,
        formatDisplay: (value) => value || 'N/A',
        isApplicable: (card) => card.isCreature && card.power && card.toughness && card.power !== '*',
        incompatibleWith: ['cardImage'],
      },
      cardImage: {
        id: 'cardImage',
        label: 'Card Image',
        canShow: true,
        canAsk: false,
        answerType: null,
        difficulty: 0,
        extractValue: (card) => card.imageUrl,
        formatDisplay: (url) => url,
        incompatibleWith: [],
      },
    };

    // ---- Validation Rules ----
    const VALIDATION_RULES = {
      minShowFields: 1,
      maxShowFields: 6,
      requiredAskField: true,

      incompatibleCombinations: {
        cardImage: ['cardName', 'manaValue', 'typeLine', 'powerToughness'],
      },

      poolRequirements: {
        powerToughness: (pool) => pool.filter(c => c.isCreature && c.power && c.toughness).length >= 4,
      },
    };

    // ---- Difficulty Weights ----
    const DIFFICULTY_WEIGHTS = {
      0: 0,
      1: 1.0,
      2: 1.5,
      3: 2.0,
      4: 3.0,
      5: 5.0,
    };

    const DIFFICULTY_LABELS = {
      0: 'N/A',
      1: 'Trivial',
      2: 'Easy',
      3: 'Medium',
      4: 'Hard',
      5: 'Expert',
    };

    const QUESTION_TYPE_LABELS = {
      manaValue: 'Mana Value',
      powerToughness: 'Power / Toughness',
      color: 'Color Identity',
      cardType: 'Card Type',
      keywords: 'Keywords',
    };

    const QUESTION_TYPE_BADGES = {
      manaValue: 'badge-mana-value',
      powerToughness: 'badge-power-toughness',
      color: 'badge-color',
      cardType: 'badge-card-type',
      keywords: 'badge-keywords',
    };

    const COLOR_MAP = { W: 'White', U: 'Blue', B: 'Black', R: 'Red', G: 'Green' };
    const ALL_COLORS = ['W', 'U', 'B', 'R', 'G'];

    const STORAGE_KEYS = {
      SCORE: 'card_quiz_api_score',
      HISTORY: 'card_quiz_api_history',
      CARD_POOL: 'card_quiz_api_pool', // Legacy key for migration
      PRESET_POOLS: 'card_quiz_preset_pools',
      CACHE_META: 'card_quiz_cache_meta',
    };

    // Set options for initial load
    const DEFAULT_SETS = ['ecl', 'tla', 'eoe', 'fdn', 'blb', 'otj', 'mkm', 'lci'];
    const ALL_CARDS_QUERY = 'game:paper -type:land'; // All non-land cards

    // Preset definitions for format-based card pools
    const PRESET_DEFINITIONS = {
      standard: {
        label: 'Standard',
        query: 'format:standard game:paper -type:land',
        ttl: 7 * 24 * 60 * 60 * 1000, // 7 days
        preCache: true,
        icon: 'âš¡',
        description: 'Current Standard-legal cards',
      },
      pioneer: {
        label: 'Pioneer',
        query: 'format:pioneer game:paper -type:land',
        ttl: 30 * 24 * 60 * 60 * 1000, // 30 days
        preCache: true,
        icon: 'ðŸ›ï¸',
        description: 'Pioneer format (Return to Ravnica onward)',
      },
      modern: {
        label: 'Modern',
        query: 'format:modern game:paper -type:land',
        ttl: 30 * 24 * 60 * 60 * 1000,
        preCache: false,
        icon: 'ðŸ”¥',
        description: 'Modern format (8th Edition onward)',
      },
      edhrec: {
        label: 'EDHREC Top',
        query: 'format:commander order:edhrec game:paper -type:land',
        ttl: 3 * 24 * 60 * 60 * 1000, // 3 days
        preCache: true,
        icon: 'ðŸ‘‘',
        description: 'Most popular Commander cards',
      },
      reprints: {
        label: 'Most Reprinted',
        query: 'game:paper -type:land is:reprint',
        sortOrder: 'prints',
        ttl: 14 * 24 * 60 * 60 * 1000,
        preCache: false,
        icon: 'â™»ï¸',
        description: 'Classic cards with many printings',
      },
      recent: {
        label: 'Recent Sets',
        query: '(set:ecl OR set:tla OR set:fdn OR set:blb) game:paper is:booster -type:land',
        ttl: 14 * 24 * 60 * 60 * 1000,
        preCache: false,
        icon: 'ðŸ†•',
        description: 'Latest Limited environment',
      },
      pauper: {
        label: 'Pauper',
        query: 'format:pauper game:paper -type:land',
        ttl: 14 * 24 * 60 * 60 * 1000,
        preCache: false,
        icon: 'ðŸ’Ž',
        description: 'Commons-only format',
      },
      vintage: {
        label: 'Vintage',
        query: 'format:vintage game:paper -type:land order:edhrec',
        ttl: 30 * 24 * 60 * 60 * 1000,
        preCache: false,
        icon: 'ðŸ†',
        description: 'Iconic cards from Magic history',
      },
    };

    // ---- Utility Functions ----

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function formatManaValue(mv) {
      return String(Math.floor(mv));
    }

    function formatColors(colors) {
      if (!colors || colors.length === 0) return 'Colorless';
      return colors.map(c => COLOR_MAP[c] || c).join(', ');
    }

    function colorsMatch(a, b) {
      const sa = [...(a || [])].sort().join('');
      const sb = [...(b || [])].sort().join('');
      return sa === sb;
    }

    function loadStorage(key, fallback) {
      try {
        const val = localStorage.getItem(key);
        return val ? JSON.parse(val) : fallback;
      } catch { return fallback; }
    }

    function saveStorage(key, val) {
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }

    // ---- Scryfall API Client ----

    class ScryfallClient {
      constructor() {
        this.baseUrl = 'https://api.scryfall.com';
        this.requestDelay = 100; // Respect 10 req/sec rate limit
        this.lastRequest = 0;

        // Migrate old cache to new format
        this.migrateOldCache();
      }

      migrateOldCache() {
        const oldCache = loadStorage(STORAGE_KEYS.CARD_POOL, null);
        if (!oldCache || !oldCache.cards) return; // No old cache

        const pools = loadStorage(STORAGE_KEYS.PRESET_POOLS, {});
        if (Object.keys(pools).length > 0) return; // Already migrated

        console.log('Migrating old cache to new preset system...');

        // Assume old cache was "entire database" â†’ map to "recent" preset
        pools.recent = {
          cards: oldCache.cards,
          timestamp: oldCache.timestamp || Date.now(),
          query: PRESET_DEFINITIONS.recent.query,
          totalAvailable: oldCache.cards.length,
          expiresAt: Date.now() + PRESET_DEFINITIONS.recent.ttl,
        };

        saveStorage(STORAGE_KEYS.PRESET_POOLS, pools);

        // Remove old cache
        try {
          localStorage.removeItem(STORAGE_KEYS.CARD_POOL);
        } catch {}

        console.log('Migration complete!');
      }

      async wait() {
        const now = Date.now();
        const elapsed = now - this.lastRequest;
        if (elapsed < this.requestDelay) {
          await new Promise(r => setTimeout(r, this.requestDelay - elapsed));
        }
        this.lastRequest = Date.now();
      }

      async search(query, page = 1) {
        await this.wait();
        const url = `${this.baseUrl}/cards/search?q=${encodeURIComponent(query)}&page=${page}&unique=cards`;
        console.log(`Scryfall API: ${url}`);
        const response = await fetch(url);

        // Handle 429 Too Many Requests
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After') || 5;
          console.warn(`Rate limited, retrying after ${retryAfter}s`);
          await new Promise(r => setTimeout(r, retryAfter * 1000));
          return await this.search(query, page); // Retry
        }

        if (!response.ok) {
          throw new Error(`Scryfall API error: ${response.status}`);
        }
        return await response.json();
      }

      async fetchCardPool(sets, limit = 200, useAllCards = false) {
        const cards = [];
        let fullQuery;

        if (useAllCards) {
          fullQuery = ALL_CARDS_QUERY;
        } else {
          const setQuery = sets.map(s => `set:${s}`).join(' OR ');
          fullQuery = `(${setQuery}) game:paper is:booster -type:land`;
        }

        // First request to get total count
        const firstPage = await this.search(fullQuery, 1);
        const totalCards = firstPage.total_cards;
        const cardsPerPage = firstPage.data.length; // Usually ~175
        const totalPages = Math.ceil(totalCards / cardsPerPage);

        console.log(`Found ${totalCards} cards across ${totalPages} pages`);

        // Add first page cards
        cards.push(...firstPage.data.map(card => this.transformCard(card)));

        // Calculate how many more pages we need
        const pagesNeeded = Math.ceil((limit - cards.length) / cardsPerPage);
        let randomPages = [];

        if (pagesNeeded > 0 && totalPages > 1) {
          // Generate random page numbers (excluding page 1 which we already fetched)
          const availablePages = Array.from({length: totalPages - 1}, (_, i) => i + 2);
          randomPages = this.pickRandomPages(availablePages, Math.min(pagesNeeded, availablePages.length));

          // Fetch random pages
          for (const page of randomPages) {
            if (cards.length >= limit) break;
            const data = await this.search(fullQuery, page);
            cards.push(...data.data.map(card => this.transformCard(card)));
          }
        }

        // Shuffle and limit
        const shuffled = this.shuffleArray(cards).slice(0, limit);
        console.log(`Fetched ${shuffled.length} cards from ${randomPages.length + 1} random pages (${totalCards} total cards available)`);
        return shuffled;
      }

      pickRandomPages(pages, count) {
        const shuffled = [...pages];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled.slice(0, count);
      }

      shuffleArray(arr) {
        const a = [...arr];
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      transformCard(scryfallCard) {
        const face = scryfallCard.card_faces ? scryfallCard.card_faces[0] : scryfallCard;

        return {
          name: scryfallCard.name,
          set: scryfallCard.set,
          rarity: scryfallCard.rarity.charAt(0).toUpperCase(),
          manaCost: face.mana_cost || scryfallCard.mana_cost || '',
          manaValue: scryfallCard.cmc || 0,
          typeLine: face.type_line || scryfallCard.type_line || '',
          oracleText: face.oracle_text || scryfallCard.oracle_text || '',
          power: face.power || null,
          toughness: face.toughness || null,
          colors: face.colors || scryfallCard.colors || [],
          colorIdentity: scryfallCard.color_identity || [],
          keywords: scryfallCard.keywords || [],
          imageUrl: scryfallCard.image_uris?.normal || scryfallCard.card_faces?.[0]?.image_uris?.normal || '',
          isCreature: (face.type_line || scryfallCard.type_line || '').includes('Creature'),
          mainType: this.getMainType(face.type_line || scryfallCard.type_line || ''),
        };
      }

      getMainType(typeLine) {
        const mainPart = typeLine.split('â€”')[0].split('//')[0].trim();
        const types = ['Creature', 'Instant', 'Sorcery', 'Enchantment', 'Artifact', 'Planeswalker', 'Land', 'Battle'];
        for (const t of types) {
          if (mainPart.includes(t)) return t;
        }
        return 'Other';
      }

      // ---- Cache Management Methods ----

      getCachedPool(presetKey) {
        const pools = loadStorage(STORAGE_KEYS.PRESET_POOLS, {});
        return pools[presetKey] || null;
      }

      cachePool(presetKey, cards, query) {
        const pools = loadStorage(STORAGE_KEYS.PRESET_POOLS, {});
        const preset = PRESET_DEFINITIONS[presetKey];
        const now = Date.now();

        pools[presetKey] = {
          cards,
          timestamp: now,
          query,
          totalAvailable: cards.length,
          expiresAt: now + preset.ttl,
        };

        // Check total size and prune if needed
        this.pruneOldPools(pools);

        saveStorage(STORAGE_KEYS.PRESET_POOLS, pools);
      }

      isExpired(cached) {
        return Date.now() > cached.expiresAt;
      }

      isStale(cached) {
        const staleWindow = 7 * 24 * 60 * 60 * 1000; // 7 days grace period
        const staleAt = cached.expiresAt + staleWindow;
        return Date.now() > cached.expiresAt && Date.now() < staleAt;
      }

      pruneOldPools(pools) {
        // Estimate localStorage size
        const sizeEstimate = JSON.stringify(pools).length;
        const MAX_SIZE = 3 * 1024 * 1024; // 3MB limit (conservative)

        if (sizeEstimate < MAX_SIZE) return;

        console.warn('localStorage approaching limit, pruning old pools...');

        // Sort pools by last access time, keep protected pools
        const entries = Object.entries(pools);
        const sorted = entries.sort((a, b) => {
          // Protect pre-cache pools
          const aProtected = PRESET_DEFINITIONS[a[0]]?.preCache;
          const bProtected = PRESET_DEFINITIONS[b[0]]?.preCache;
          if (aProtected && !bProtected) return 1;
          if (!aProtected && bProtected) return -1;

          // Sort by timestamp (oldest first)
          return a[1].timestamp - b[1].timestamp;
        });

        // Remove oldest non-protected pool
        const toRemove = sorted.find(([key, _]) => !PRESET_DEFINITIONS[key]?.preCache);
        if (toRemove) {
          console.log(`Removing old pool: ${toRemove[0]}`);
          delete pools[toRemove[0]];
        }
      }

      backgroundRefresh(presetKey) {
        // Queue background refresh (non-blocking)
        setTimeout(async () => {
          try {
            console.log(`Background refresh started for ${presetKey}`);
            await this.fetchPresetPool(presetKey, true); // Force fresh
            console.log(`Background refresh complete for ${presetKey}`);
          } catch (err) {
            console.error(`Background refresh failed for ${presetKey}:`, err);
          }
        }, 1000); // Small delay to not interfere with user interaction
      }

      async fetchPresetPool(presetKey, forceFresh = false) {
        // 1. Check cache
        const cached = this.getCachedPool(presetKey);

        // 2. Is cache valid?
        if (!forceFresh && cached && !this.isExpired(cached)) {
          console.log(`Using cached pool for ${presetKey}`);

          // 3. Is cache stale? Background refresh
          if (this.isStale(cached)) {
            console.log(`Pool is stale, refreshing in background`);
            this.backgroundRefresh(presetKey);
          }

          return cached.cards;
        }

        // 4. No cache or expired â†’ fetch fresh
        const preset = PRESET_DEFINITIONS[presetKey];
        const query = preset.query;
        const cards = await this.fetchByQuery(query, 200);

        // 5. Cache result
        this.cachePool(presetKey, cards, query);

        return cards;
      }

      async fetchByQuery(query, limit) {
        const cards = [];
        const firstPage = await this.search(query, 1);
        const totalCards = firstPage.total_cards;
        const cardsPerPage = firstPage.data.length;
        const totalPages = Math.ceil(totalCards / cardsPerPage);

        console.log(`Found ${totalCards} cards across ${totalPages} pages`);

        cards.push(...firstPage.data.map(card => this.transformCard(card)));

        const pagesNeeded = Math.ceil((limit - cards.length) / cardsPerPage);

        // Auto-detect: if query has 'order:', fetch sequentially to preserve sort
        const isSorted = query.includes('order:');

        if (pagesNeeded > 0 && totalPages > 1) {
          if (isSorted) {
            // Sequential fetch (pages 2, 3, 4...) to preserve order
            console.log(`Sorted query detected, fetching sequentially...`);
            for (let page = 2; page <= Math.min(totalPages, pagesNeeded + 1); page++) {
              if (cards.length >= limit) break;
              const data = await this.search(query, page);
              cards.push(...data.data.map(card => this.transformCard(card)));
            }

            // Take first N cards (preserves order)
            return cards.slice(0, limit);
          } else {
            // Random pages for unsorted queries (faster)
            const availablePages = Array.from({length: totalPages - 1}, (_, i) => i + 2);
            const randomPages = this.pickRandomPages(availablePages, Math.min(pagesNeeded, availablePages.length));

            for (const page of randomPages) {
              if (cards.length >= limit) break;
              const data = await this.search(query, page);
              cards.push(...data.data.map(card => this.transformCard(card)));
            }

            // Shuffle for variety
            return this.shuffleArray(cards).slice(0, limit);
          }
        }

        return isSorted ? cards.slice(0, limit) : this.shuffleArray(cards).slice(0, limit);
      }
    }

    // ---- Question Generator (same as before) ----
    function generateQuestion(cards, questionTypeFilter = 'all') {
      if (cards.length < 2) return null;

      // No filtering - cards are already filtered by Scryfall query
      const pool = [...cards];

      // Determine valid question types
      let validTypes = [...QUESTION_TYPES];

      // Apply question type filter if specified
      if (questionTypeFilter && questionTypeFilter !== 'all') {
        validTypes = validTypes.filter(t => t === questionTypeFilter);
      }

      const creatures = pool.filter(c => c.isCreature && c.power && c.toughness && c.power !== '*');
      const withKeywords = pool.filter(c => c.keywords.length > 0);

      if (creatures.length < 2) validTypes = validTypes.filter(t => t !== 'powerToughness');
      if (withKeywords.length < 2) validTypes = validTypes.filter(t => t !== 'keywords');

      if (validTypes.length === 0) return null;

      const questionType = pickRandom(validTypes);

      let cardPool = questionType === 'powerToughness' ? creatures
        : questionType === 'keywords' ? withKeywords
        : pool;

      const card = pickRandom(cardPool);

      // Generate distractors from the same pool
      const generateDistractors = (correctValue, extractor, count = 3) => {
        const values = [...new Set(pool.map(extractor))].filter(v => v !== correctValue);
        return shuffle(values).slice(0, count);
      };

      switch (questionType) {
        case 'manaValue': {
          const correctMV = card.manaValue;
          const distractors = generateDistractors(correctMV, c => c.manaValue);
          const options = shuffle([correctMV, ...distractors]).map(v => ({
            value: formatManaValue(v),
            label: formatManaValue(v),
            isCorrect: v === correctMV,
          }));
          return {
            type: 'manaValue',
            card,
            questionText: `What is the mana value of`,
            hint: card.typeLine,
            options,
            correctAnswer: formatManaValue(correctMV),
            format: 'mc',
          };
        }

        case 'powerToughness': {
          const correctPT = `${card.power}/${card.toughness}`;
          const distractors = generateDistractors(correctPT, c => `${c.power}/${c.toughness}`);
          const options = shuffle([correctPT, ...distractors]).map(v => ({
            value: v,
            label: v,
            isCorrect: v === correctPT,
          }));
          return {
            type: 'powerToughness',
            card,
            questionText: `What is the power/toughness of`,
            hint: `${card.typeLine} (MV ${formatManaValue(card.manaValue)})`,
            options,
            correctAnswer: correctPT,
            format: 'mc',
          };
        }

        case 'color': {
          const correctColors = card.colors.length > 0 ? [...card.colors].sort() : [];
          return {
            type: 'color',
            card,
            questionText: `What color(s) is`,
            hint: card.typeLine,
            correctColors,
            correctAnswer: correctColors.length > 0 ? formatColors(correctColors) : 'Colorless',
            format: 'color',
          };
        }

        case 'cardType': {
          const correctType = card.mainType;
          const distractors = generateDistractors(correctType, c => c.mainType);
          const options = shuffle([correctType, ...distractors]).map(v => ({
            value: v,
            label: v,
            isCorrect: v === correctType,
          }));
          return {
            type: 'cardType',
            card,
            questionText: `What type of card is`,
            hint: card.manaCost ? `Mana cost: ${card.manaCost}` : 'No mana cost',
            options,
            correctAnswer: correctType,
            format: 'mc',
          };
        }

        case 'keywords': {
          const correctKW = [...card.keywords].sort();
          const distractors = generateDistractors(correctKW.join(','), c => c.keywords.sort().join(','))
            .map(kw => kw.split(','));
          const options = shuffle([correctKW, ...distractors]).map(kws => ({
            value: kws.join(', '),
            label: kws.join(', '),
            isCorrect: kws.sort().join(',') === correctKW.join(','),
          }));
          return {
            type: 'keywords',
            card,
            questionText: `What keyword abilities does`,
            hint: `${card.typeLine} â€” ${card.power}/${card.toughness}`,
            options,
            correctAnswer: correctKW.join(', '),
            format: 'mc',
          };
        }

        default:
          return null;
      }
    }

    // ---- Custom Quiz Validation ----

    function validateQuizConfig(config, cardPool) {
      const errors = [];

      // Check minimum show fields
      const shownFields = config.shownFields.filter(id => id !== config.askField);
      if (shownFields.length < VALIDATION_RULES.minShowFields) {
        errors.push(`Must show at least ${VALIDATION_RULES.minShowFields} field(s)`);
      }

      // Check ask field is selected
      if (!config.askField) {
        errors.push('Must select a field to ask');
      }

      // Check for incompatible combinations
      const allFields = [...config.shownFields, config.askField];
      for (const fieldId of allFields) {
        const field = FIELD_DEFINITIONS[fieldId];
        if (!field) continue;

        const incompatible = field.incompatibleWith || [];
        for (const otherFieldId of allFields) {
          if (otherFieldId === fieldId) continue;
          if (incompatible.includes(otherFieldId)) {
            errors.push(`${field.label} cannot be used with ${FIELD_DEFINITIONS[otherFieldId]?.label}`);
          }
        }
      }

      // Check pool requirements for specific field types
      if (config.askField === 'powerToughness') {
        const validCreatures = cardPool.filter(c =>
          c.isCreature && c.power && c.toughness && c.power !== '*'
        );
        if (validCreatures.length < 4) {
          errors.push('Not enough creatures with P/T in card pool (need at least 4)');
        }
      }

      return errors;
    }

    function getApplicableCards(cardPool, config) {
      // Filter cards to only those where the ask field is applicable
      const askField = FIELD_DEFINITIONS[config.askField];
      if (!askField) return cardPool;

      if (askField.isApplicable) {
        return cardPool.filter(card => askField.isApplicable(card));
      }

      return cardPool;
    }

    // ---- Custom Question Generator ----

    function generateCustomQuestion(cardPool, config) {
      if (!cardPool || cardPool.length < 2) return null;
      if (!config.askField) return null;

      // Get applicable cards
      const applicableCards = getApplicableCards(cardPool, config);
      if (applicableCards.length < 2) return null;

      // Pick a random card
      const card = pickRandom(applicableCards);

      const askField = FIELD_DEFINITIONS[config.askField];
      const correctValue = askField.extractValue(card);

      if (correctValue === null || correctValue === undefined) return null;

      // Build question text
      const shownFieldsText = config.shownFields
        .filter(id => id !== config.askField)
        .map(id => {
          const field = FIELD_DEFINITIONS[id];
          const value = field.extractValue(card);
          return `${field.label}: ${field.formatDisplay(value)}`;
        })
        .join(', ');

      const questionText = `What is the ${askField.label}?`;

      // Generate question based on answer type
      let question = {
        type: 'custom',
        card,
        askFieldId: config.askField,
        questionText,
        shownInfo: shownFieldsText,
        answerType: askField.answerType,
        difficulty: askField.difficulty,
      };

      switch (askField.answerType) {
        case 'text': {
          // Text input for card name
          question.correctAnswer = correctValue;
          question.checkAnswer = (userAnswer) => {
            const normalized = userAnswer.toLowerCase().trim();
            const correct = correctValue.toLowerCase().trim();
            return normalized === correct;
          };
          break;
        }

        case 'number': {
          // Number input for mana value
          question.correctAnswer = Math.floor(correctValue);
          question.checkAnswer = (userAnswer) => {
            return parseInt(userAnswer) === Math.floor(correctValue);
          };
          break;
        }

        case 'colorPicker': {
          // Color picker for colors
          question.correctColors = correctValue;
          question.correctAnswer = correctValue.length > 0 ? correctValue.join('') : 'Colorless';
          question.checkAnswer = (userColors) => {
            if (!Array.isArray(userColors)) return false;
            if (userColors.length !== correctValue.length) return false;
            const sortedUser = [...userColors].sort().join('');
            const sortedCorrect = [...correctValue].sort().join('');
            return sortedUser === sortedCorrect;
          };
          break;
        }

        case 'multipleChoice': {
          // Multiple choice for type line or P/T
          const generateDistractors = (count = 3) => {
            const allValues = applicableCards
              .map(c => askField.extractValue(c))
              .filter(v => v !== null && v !== undefined && v !== correctValue);

            const uniqueValues = [...new Set(allValues)];
            return shuffle(uniqueValues).slice(0, count);
          };

          const distractors = generateDistractors(3);
          if (distractors.length < 3) return null; // Not enough variety

          const options = shuffle([correctValue, ...distractors]).map(value => ({
            value,
            label: askField.formatDisplay(value),
            isCorrect: value === correctValue,
          }));

          question.options = options;
          question.correctAnswer = askField.formatDisplay(correctValue);
          question.checkAnswer = (selectedIdx) => {
            return options[selectedIdx]?.isCorrect || false;
          };
          break;
        }

        default:
          return null;
      }

      return question;
    }

    // ---- Components ----

    function ScoreBar({ score }) {
      const accuracy = score.questions > 0 ? Math.round((score.correct / score.questions) * 100) : 0;
      return (
        <div className="score-bar">
          <div className="score-item">
            <div className="score-label">Score</div>
            <div className="score-value">{score.points}</div>
          </div>
          <div className="score-item">
            <div className="score-label">Correct</div>
            <div className="score-value">{score.correct}/{score.questions}</div>
          </div>
          <div className="score-item">
            <div className="score-label">Accuracy</div>
            <div className="score-value accuracy">{accuracy}%</div>
          </div>
          <div className="score-item">
            <div className="score-label">Streak</div>
            <div className="score-value streak">{score.streak}</div>
          </div>
        </div>
      );
    }

    function PresetToggleBar({ activePreset, onPresetChange, loadingPresets }) {
      const [showAll, setShowAll] = React.useState(false);

      // Primary presets always visible
      const primaryPresets = ['standard', 'pioneer', 'modern', 'edhrec'];

      // Secondary presets in "More" dropdown
      const secondaryPresets = ['reprints', 'recent', 'pauper', 'vintage'];

      const renderButton = (key) => {
        const preset = PRESET_DEFINITIONS[key];
        const isActive = activePreset === key;
        const isLoading = loadingPresets.has(key);

        return (
          <button
            key={key}
            className={`preset-btn ${isActive ? 'active' : ''} ${isLoading ? 'loading' : ''}`}
            onClick={() => onPresetChange(key)}
            disabled={isLoading}
          >
            {isLoading && <span className="spinner-mini"></span>}
            {preset.icon} {preset.label}
            {isActive && ' âœ“'}
          </button>
        );
      };

      return (
        <div className="preset-toggle-bar">
          <div className="preset-primary">
            {primaryPresets.map(renderButton)}
          </div>

          <div className="preset-more">
            <button
              className="preset-more-btn"
              onClick={() => setShowAll(!showAll)}
            >
              More {showAll ? 'â–´' : 'â–¾'}
            </button>

            {showAll && (
              <div className="preset-secondary">
                {secondaryPresets.map(renderButton)}
              </div>
            )}
          </div>
        </div>
      );
    }

    function SearchField({ query, onChange, onSearch }) {
      const [localQuery, setLocalQuery] = React.useState(query);

      const handleKeyPress = (e) => {
        if (e.key === 'Enter') {
          onSearch(localQuery);
        }
      };

      React.useEffect(() => {
        setLocalQuery(query);
      }, [query]);

      return (
        <div className="search-field-container">
          <input
            type="text"
            className="search-input"
            value={localQuery}
            onChange={(e) => setLocalQuery(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Scryfall syntax: format:standard color:red rarity:m"
          />
          <button className="search-btn" onClick={() => onSearch(localQuery)}>
            ðŸ” Search
          </button>
          <div className="search-hint">
            <a href="https://scryfall.com/docs/syntax" target="_blank">Scryfall syntax guide</a>
          </div>
        </div>
      );
    }

    function FilterBar({ searchQuery, onSearchChange }) {
      // Parse current query to extract active filters
      const activeFilters = React.useMemo(() => {
        const colorMatch = searchQuery.match(/color:([WUBRG])/);
        const rarityMatch = searchQuery.match(/rarity:([curmCURM])/);

        return {
          color: colorMatch ? colorMatch[1].toUpperCase() : 'all',
          rarity: rarityMatch ? rarityMatch[1].toUpperCase() : 'all',
        };
      }, [searchQuery]);

      const updateQuery = (filterType, value) => {
        let newQuery = searchQuery;

        // Remove existing filter of this type
        if (filterType === 'color') {
          newQuery = newQuery.replace(/color:[WUBRG]\s*/g, '').trim();
          if (value !== 'all') {
            newQuery += ` color:${value}`;
          }
        } else if (filterType === 'rarity') {
          newQuery = newQuery.replace(/rarity:[curmCURM]\s*/g, '').trim();
          if (value !== 'all') {
            newQuery += ` rarity:${value.toLowerCase()}`;
          }
        }

        // Clean up extra spaces
        newQuery = newQuery.replace(/\s+/g, ' ').trim();
        onSearchChange(newQuery);
      };

      return (
        <div className="filters">
          <select className="filter-select" value={activeFilters.color} onChange={e => updateQuery('color', e.target.value)}>
            <option value="all">All Colors</option>
            <option value="W">White</option>
            <option value="U">Blue</option>
            <option value="B">Black</option>
            <option value="R">Red</option>
            <option value="G">Green</option>
          </select>

          <select className="filter-select" value={activeFilters.rarity} onChange={e => updateQuery('rarity', e.target.value)}>
            <option value="all">All Rarities</option>
            <option value="C">Common</option>
            <option value="U">Uncommon</option>
            <option value="R">Rare</option>
            <option value="M">Mythic</option>
          </select>
        </div>
      );
    }

    function MultipleChoice({ options, onSelect, selectedIdx, disabled }) {
      return (
        <div className="mc-options">
          {options.map((opt, i) => {
            let className = 'mc-option';
            if (disabled) className += ' disabled';
            if (selectedIdx !== null) {
              if (i === selectedIdx && opt.isCorrect) className += ' selected-correct';
              else if (i === selectedIdx && !opt.isCorrect) className += ' selected-wrong';
              else if (opt.isCorrect) className += ' reveal-correct';
            }
            return <button key={i} className={className} onClick={() => !disabled && onSelect(i)} disabled={disabled}>{opt.label}</button>;
          })}
        </div>
      );
    }

    function ColorPicker({ onSubmit, disabled, correctColors, submitted, userColors }) {
      const [selected, setSelected] = useState([]);

      useEffect(() => { setSelected([]); }, [correctColors]);

      const toggle = (color) => {
        if (disabled) return;
        if (color === 'C') {
          setSelected(prev => prev.includes('C') ? [] : ['C']);
        } else {
          setSelected(prev => {
            const without = prev.filter(c => c !== 'C');
            return without.includes(color) ? without.filter(c => c !== color) : [...without, color];
          });
        }
      };

      const handleSubmit = () => {
        const answer = selected.includes('C') ? [] : selected.sort();
        onSubmit(answer);
      };

      const allBtns = [...ALL_COLORS, 'C'];
      const displaySelected = submitted ? userColors : selected;

      return (
        <div>
          <div className="color-picker">
            {allBtns.map(c => (
              <button
                key={c}
                className={`color-btn ${c} ${displaySelected.includes(c) || (c === 'C' && displaySelected.length === 0 && submitted) ? 'selected' : ''} ${disabled ? 'disabled' : ''}`}
                onClick={() => toggle(c)}
                disabled={disabled}
              >
                {c === 'C' ? 'None' : COLOR_MAP[c]?.[0] || c}
              </button>
            ))}
          </div>
          {!submitted && (
            <button className="color-submit-btn" onClick={handleSubmit} disabled={disabled || selected.length === 0}>
              Submit
            </button>
          )}
          {submitted && (
            <div style={{ marginTop: 12, fontSize: '0.85rem', color: 'var(--text-muted)', textAlign: 'center' }}>
              Correct: {correctColors.length > 0 ? correctColors.map(c => COLOR_MAP[c]).join(', ') : 'Colorless'}
            </div>
          )}
        </div>
      );
    }

    function TextInput({ onSubmit, disabled, placeholder }) {
      const [value, setValue] = useState('');

      const handleSubmit = () => {
        if (value.trim()) {
          onSubmit(value.trim());
        }
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter' && !disabled && value.trim()) {
          handleSubmit();
        }
      };

      return (
        <div className="text-input-container">
          <input
            type="text"
            className="text-input"
            value={value}
            onChange={(e) => setValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder={placeholder || 'Enter your answer...'}
            disabled={disabled}
          />
          <button
            className="submit-answer-btn"
            onClick={handleSubmit}
            disabled={disabled || !value.trim()}
          >
            Submit
          </button>
        </div>
      );
    }

    function NumberInput({ onSubmit, disabled, min, max }) {
      const [value, setValue] = useState('');

      const handleSubmit = () => {
        if (value.trim()) {
          onSubmit(value.trim());
        }
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter' && !disabled && value.trim()) {
          handleSubmit();
        }
      };

      const handleChange = (e) => {
        const val = e.target.value;
        // Allow empty, numbers, and basic validation
        if (val === '' || /^\d+$/.test(val)) {
          setValue(val);
        }
      };

      return (
        <div className="number-input-container">
          <input
            type="number"
            className="number-input"
            value={value}
            onChange={handleChange}
            onKeyPress={handleKeyPress}
            placeholder={`Enter a number${min !== undefined ? ` (${min}-${max})` : ''}...`}
            disabled={disabled}
            min={min}
            max={max}
          />
          <button
            className="submit-answer-btn"
            onClick={handleSubmit}
            disabled={disabled || !value.trim()}
          >
            Submit
          </button>
        </div>
      );
    }

    function AnswerInput({ field, question, onSubmit, disabled }) {
      if (!field) {
        return <div style={{ color: 'var(--wrong)', padding: '12px' }}>Error: No field definition</div>;
      }

      switch (field.answerType) {
        case 'text':
          return (
            <TextInput
              onSubmit={onSubmit}
              disabled={disabled}
              placeholder={`Enter ${field.label.toLowerCase()}...`}
            />
          );

        case 'number':
          return (
            <NumberInput
              onSubmit={onSubmit}
              disabled={disabled}
              min={field.min}
              max={field.max}
            />
          );

        case 'colorPicker':
          return (
            <ColorPicker
              onSubmit={onSubmit}
              disabled={disabled}
              correctColors={question?.correctColors || []}
              submitted={disabled}
              userColors={question?.userColors || []}
            />
          );

        case 'multipleChoice':
          return (
            <MultipleChoice
              options={question?.options || []}
              onSelect={(idx) => {
                const option = question.options[idx];
                onSubmit(option?.value || option?.label);
              }}
              selectedIdx={null}
              disabled={disabled}
            />
          );

        default:
          return (
            <div style={{ color: 'var(--text-muted)', padding: '12px', textAlign: 'center' }}>
              Unsupported answer type: {field.answerType}
            </div>
          );
      }
    }

    // ---- Custom Mode Components (Sprint 2) ----

    function FieldConfigTable({ config, onConfigChange, validationErrors }) {
      const fieldIds = Object.keys(FIELD_DEFINITIONS);

      const isIncompatible = (fieldId, askField) => {
        if (!config.shownFields.includes(fieldId)) return false;
        const incompatible = FIELD_DEFINITIONS[fieldId]?.incompatibleWith || [];
        return incompatible.includes(askField);
      };

      const isDisabledForShow = (fieldId) => {
        // Check if this field is incompatible with current ask field
        if (config.askField && isIncompatible(fieldId, config.askField)) {
          return true;
        }
        return false;
      };

      const isDisabledForAsk = (fieldId) => {
        const field = FIELD_DEFINITIONS[fieldId];
        if (!field || !field.canAsk) return true;

        // Check if asking this field would be incompatible with shown fields
        for (const shownId of config.shownFields) {
          const incompatible = FIELD_DEFINITIONS[shownId]?.incompatibleWith || [];
          if (incompatible.includes(fieldId)) {
            return true;
          }
        }
        return false;
      };

      return (
        <table className="field-config-table">
          <thead>
            <tr>
              <th>Field</th>
              <th>Show</th>
              <th>Ask</th>
              <th>Difficulty</th>
            </tr>
          </thead>
          <tbody>
            {fieldIds.map(fieldId => {
              const field = FIELD_DEFINITIONS[fieldId];
              const isShown = config.shownFields.includes(fieldId);
              const isAsked = config.askField === fieldId;

              return (
                <tr key={fieldId}>
                  <td><strong>{field.label}</strong></td>
                  <td>
                    <input
                      type="checkbox"
                      checked={isShown}
                      onChange={(e) => {
                        if (e.target.checked) {
                          onConfigChange({
                            ...config,
                            shownFields: [...config.shownFields, fieldId],
                          });
                        } else {
                          onConfigChange({
                            ...config,
                            shownFields: config.shownFields.filter(id => id !== fieldId),
                          });
                        }
                      }}
                      disabled={isDisabledForShow(fieldId) || !field.canShow}
                    />
                  </td>
                  <td>
                    <input
                      type="radio"
                      name="askField"
                      checked={isAsked}
                      onChange={() => {
                        onConfigChange({
                          ...config,
                          askField: fieldId,
                        });
                      }}
                      disabled={isDisabledForAsk(fieldId)}
                    />
                  </td>
                  <td>
                    <span className={`difficulty-badge difficulty-${field.difficulty}`}>
                      {DIFFICULTY_LABELS[field.difficulty]}
                    </span>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      );
    }

    function PreviewPanel({ config, cardPool }) {
      const sampleCard = cardPool && cardPool.length > 0 ? cardPool[0] : null;

      if (!sampleCard || !config.askField) {
        return (
          <div className="preview-panel">
            <h4>Preview</h4>
            <div className="preview-error">
              Configure settings to see a preview
            </div>
          </div>
        );
      }

      const askField = FIELD_DEFINITIONS[config.askField];

      try {
        return (
          <div className="preview-panel">
            <h4>Preview</h4>
            <div className="preview-content">
              {config.shownFields.map(fieldId => {
                const field = FIELD_DEFINITIONS[fieldId];
                const value = field.extractValue(sampleCard);

                if (fieldId === 'cardImage') {
                  return (
                    <div key={fieldId} className="preview-field">
                      {value && (
                        <img
                          src={value}
                          alt="Card"
                          style={{
                            maxWidth: '150px',
                            maxHeight: '200px',
                            borderRadius: '6px',
                            margin: '8px 0',
                          }}
                        />
                      )}
                    </div>
                  );
                }

                return (
                  <div key={fieldId} className="preview-field">
                    <strong>{field.label}:</strong>{' '}
                    {field.formatDisplay(value)}
                  </div>
                );
              })}

              <div className="preview-question">
                What is the {askField.label}?
              </div>

              <div className="preview-answer blurred">
                {askField.formatDisplay(askField.extractValue(sampleCard))}
              </div>
            </div>
          </div>
        );
      } catch (err) {
        return (
          <div className="preview-panel">
            <h4>Preview</h4>
            <div className="preview-error">
              Error generating preview: {err.message}
            </div>
          </div>
        );
      }
    }

    function QuizConfigPanel({ config, onConfigChange, cardPool }) {
      const validationErrors = [];
      if (!config.shownFields || config.shownFields.length === 0) {
        validationErrors.push('Select at least one field to show');
      }
      if (!config.askField) {
        validationErrors.push('Select a field to ask about');
      }

      return (
        <div className="config-panel">
          <div className="config-header">
            <h3>Custom Quiz Configuration</h3>
          </div>

          <FieldConfigTable
            config={config}
            onConfigChange={onConfigChange}
            validationErrors={validationErrors}
          />

          <PreviewPanel config={config} cardPool={cardPool} />

          {validationErrors.length > 0 && (
            <div className="validation-messages">
              {validationErrors.map((error, idx) => (
                <div key={idx} className="validation-error">
                  <span>âš ï¸</span>
                  <span>{error}</span>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    function FeedbackSection({ question, isCorrect, pointsEarned, streakBonus, onNext }) {
      const [imageLoaded, setImageLoaded] = useState(false);
      const card = question.card;

      return (
        <div className="feedback-section">
          <div className={`feedback-result ${isCorrect ? 'correct' : 'wrong'}`}>
            {isCorrect ? 'Correct!' : 'Wrong'}
          </div>
          <div className="feedback-detail">
            {!isCorrect && <span>The answer was <strong>{question.correctAnswer}</strong></span>}
            {isCorrect && pointsEarned > 100 && <span>+{pointsEarned} points {streakBonus > 1 ? `(${streakBonus}x streak!)` : ''}</span>}
            {isCorrect && pointsEarned <= 100 && <span>+{pointsEarned} points</span>}
          </div>

          {card.imageUrl && (
            <img
              className="feedback-card-image"
              src={card.imageUrl}
              alt={card.name}
              onLoad={() => setImageLoaded(true)}
              style={{ display: imageLoaded ? 'block' : 'none' }}
            />
          )}
          {card.imageUrl && !imageLoaded && (
            <div className="loading" style={{ padding: '20px' }}>
              <div className="loading-spinner"></div>
            </div>
          )}

          <div className="feedback-stats">
            <span>{card.manaCost || 'No cost'}</span>
            <span>MV {formatManaValue(card.manaValue)}</span>
            {card.power && <span>{card.power}/{card.toughness}</span>}
            <span>Set: {card.set.toUpperCase()}</span>
          </div>

          <button className="next-btn" onClick={onNext}>Next Question</button>
        </div>
      );
    }

    // ---- Main App ----

    function CardKnowledgeQuiz() {
      const [cardPool, setCardPool] = useState(null);
      const [loading, setLoading] = useState(true);
      const [loadingMessage, setLoadingMessage] = useState('Initializing...');
      const [error, setError] = useState(null);

      const [searchQuery, setSearchQuery] = useState('format:standard game:paper -type:land');
      const [isSearching, setIsSearching] = useState(false);

      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [selectedIdx, setSelectedIdx] = useState(null);
      const [showFeedback, setShowFeedback] = useState(false);
      const [isCorrect, setIsCorrect] = useState(false);
      const [pointsEarned, setPointsEarned] = useState(0);
      const [streakBonus, setStreakBonus] = useState(1);
      const [colorSubmitted, setColorSubmitted] = useState(false);
      const [userColorAnswer, setUserColorAnswer] = useState([]);
      const [streakPopup, setStreakPopup] = useState(null);

      const [score, setScore] = useState(() => loadStorage(STORAGE_KEYS.SCORE, {
        points: 0, questions: 0, correct: 0, streak: 0, bestStreak: 0,
      }));
      const [history, setHistory] = useState(() => loadStorage(STORAGE_KEYS.HISTORY, []));

      const [activePreset, setActivePreset] = useState(() =>
        loadStorage(STORAGE_KEYS.CACHE_META, {})?.activePreset || 'standard'
      );
      const [loadingPresets, setLoadingPresets] = useState(new Set());
      const [backgroundRefreshing, setBackgroundRefreshing] = useState(new Set());

      // Custom mode state
      const [customMode, setCustomMode] = useState(false);
      const [quizConfig, setQuizConfig] = useState(() =>
        loadStorage('card_quiz_custom_config', {
          shownFields: ['colors', 'typeLine', 'manaValue'],
          askField: 'cardName',
        })
      );
      const [validationErrors, setValidationErrors] = useState([]);
      const [showConfigPanel, setShowConfigPanel] = useState(false);

      // Question type filter for predefined mode
      const [questionTypeFilter, setQuestionTypeFilter] = useState('all');

      const scryfall = useRef(new ScryfallClient());

      // Load initial preset pool
      useEffect(() => {
        const loadCards = async () => {
          try {
            setLoadingMessage(`Loading ${PRESET_DEFINITIONS[activePreset].label} cards...`);
            const cards = await scryfall.current.fetchPresetPool(activePreset, false);
            setCardPool(cards);
            setLoading(false);
          } catch (err) {
            setError(err.message);
            setLoading(false);
          }
        };

        loadCards();
      }, []);

      // Generate first question
      useEffect(() => {
        if (cardPool && !currentQuestion) {
          nextQuestion();
        }
      }, [cardPool]);

      // Save state
      useEffect(() => { saveStorage(STORAGE_KEYS.SCORE, score); }, [score]);
      useEffect(() => { saveStorage(STORAGE_KEYS.HISTORY, history); }, [history]);
      useEffect(() => { saveStorage('card_quiz_custom_config', quizConfig); }, [quizConfig]);

      // Validate custom quiz config
      useEffect(() => {
        if (customMode && cardPool) {
          const errors = validateQuizConfig(quizConfig, cardPool);
          setValidationErrors(errors);
        } else {
          setValidationErrors([]);
        }
      }, [customMode, quizConfig, cardPool]);

      // Pre-cache common presets in background
      useEffect(() => {
        const preCachePresets = async () => {
          const toPreCache = Object.entries(PRESET_DEFINITIONS)
            .filter(([_, def]) => def.preCache)
            .map(([key, _]) => key);

          for (const key of toPreCache) {
            if (key === activePreset) continue; // Already loaded

            // Check if already cached and fresh
            const cached = scryfall.current.getCachedPool(key);
            if (cached && !scryfall.current.isExpired(cached)) {
              console.log(`${key} already cached and fresh`);
              continue;
            }

            // Background fetch
            console.log(`Pre-caching ${key} in background...`);
            setBackgroundRefreshing(prev => new Set(prev).add(key));

            try {
              await scryfall.current.fetchPresetPool(key, false);
              console.log(`${key} pre-cached successfully`);
            } catch (err) {
              console.error(`Failed to pre-cache ${key}:`, err);
            } finally {
              setBackgroundRefreshing(prev => {
                const next = new Set(prev);
                next.delete(key);
                return next;
              });
            }

            // Respect rate limits between pre-cache fetches
            await new Promise(r => setTimeout(r, 2000));
          }
        };

        // Start pre-caching after initial load completes
        if (cardPool) {
          setTimeout(preCachePresets, 1000); // Wait 1s after quiz is interactive
        }
      }, [cardPool]);

      // Auto-search when searchQuery changes (in custom mode only, debounced)
      useEffect(() => {
        if (!customMode) return; // Only apply in custom mode
        if (!cardPool) return; // Don't trigger on initial load

        const timer = setTimeout(() => {
          handleSearch(searchQuery);
        }, 800); // 800ms debounce to avoid rapid API calls

        return () => clearTimeout(timer);
      }, [searchQuery, customMode]);

      const nextQuestion = useCallback(() => {
        if (!cardPool) return;

        // Use custom question generator if in custom mode
        const q = customMode && validationErrors.length === 0
          ? generateCustomQuestion(cardPool, quizConfig)
          : generateQuestion(cardPool, questionTypeFilter);

        if (!q) {
          setError('Unable to generate question. Try different settings.');
          return;
        }

        setCurrentQuestion(q);
        setSelectedIdx(null);
        setShowFeedback(false);
        setIsCorrect(false);
        setPointsEarned(0);
        setStreakBonus(1);
        setColorSubmitted(false);
        setUserColorAnswer([]);
      }, [cardPool, customMode, quizConfig, validationErrors, questionTypeFilter]);

      const handleAnswer = useCallback((correct, userAnswer) => {
        const streakMult = score.streak >= 10 ? 3 : score.streak >= 5 ? 2 : score.streak >= 3 ? 1.5 : 1;

        // Apply difficulty multiplier for custom mode
        let difficultyMult = 1;
        if (customMode && currentQuestion?.difficulty !== undefined) {
          difficultyMult = DIFFICULTY_WEIGHTS[currentQuestion.difficulty] || 1;
        }

        const basePoints = correct ? 100 : 0;
        const earned = Math.round(basePoints * streakMult * difficultyMult);
        const newStreak = correct ? score.streak + 1 : 0;
        const bestStreak = Math.max(score.bestStreak, newStreak);

        if (correct && (newStreak === 5 || newStreak === 10 || newStreak === 15 || newStreak === 20 || newStreak === 25)) {
          setStreakPopup(newStreak);
          setTimeout(() => setStreakPopup(null), 900);
        }

        setIsCorrect(correct);
        setPointsEarned(earned);
        setStreakBonus(streakMult);
        setShowFeedback(true);

        setScore({
          points: score.points + earned,
          questions: score.questions + 1,
          correct: score.correct + (correct ? 1 : 0),
          streak: newStreak,
          bestStreak,
        });

        setHistory(prev => [...prev, {
          type: currentQuestion.type,
          cardName: currentQuestion.card.name,
          correct,
          userAnswer: userAnswer || '',
          correctAnswer: currentQuestion.correctAnswer,
          timestamp: new Date().toISOString(),
        }]);
        // Trigger background pool expansion after answer
        setTimeout(() => expandPoolInBackground(), 1000);
      }, [score, currentQuestion, cardPool, searchQuery, isSearching]);

      // Background pool expansion
      const expandPoolInBackground = useCallback(async () => {
        if (!cardPool || cardPool.length >= 100) return; // Pool is healthy
        if (isSearching) return; // Don't interfere with active search

        console.log(`Pool low (${cardPool.length} cards), expanding in background...`);

        try {
          const moreCards = await scryfall.current.fetchByQuery(searchQuery, 100);

          // Merge with existing pool (deduplicate by name)
          const existingNames = new Set(cardPool.map(c => c.name));
          const newCards = moreCards.filter(c => !existingNames.has(c.name));

          if (newCards.length > 0) {
            console.log(`Added ${newCards.length} new cards to pool`);
            setCardPool(prev => [...prev, ...newCards]);
          }
        } catch (err) {
          console.error('Background expansion failed:', err);
        }
      }, [cardPool, searchQuery, isSearching]);

      const handleMCSelect = useCallback((idx) => {
        if (selectedIdx !== null) return;
        setSelectedIdx(idx);
        const option = currentQuestion.options[idx];
        handleAnswer(option.isCorrect, option.label);
      }, [selectedIdx, currentQuestion, handleAnswer]);

      const handleColorSubmit = useCallback((userColors) => {
        setColorSubmitted(true);
        const correct = colorsMatch(userColors, currentQuestion.correctColors);
        const userAnswer = userColors.length > 0 ? formatColors(userColors) : 'Colorless';
        setUserColorAnswer(userColors.length > 0 ? userColors : ['C']);
        handleAnswer(correct, userAnswer);
      }, [currentQuestion, handleAnswer]);

      const handleRefresh = async () => {
        if (confirm(`Fetch fresh ${PRESET_DEFINITIONS[activePreset].label} cards? This will replace your current card pool.`)) {
          setLoading(true);
          setLoadingMessage('Fetching fresh cards...');
          try {
            const cards = await scryfall.current.fetchPresetPool(activePreset, true);
            setCardPool(cards);
            setLoading(false);
            nextQuestion();
          } catch (err) {
            setError(err.message);
            setLoading(false);
          }
        }
      };

      const handleSearch = async (query) => {
        if (!query.trim()) {
          alert('Please enter a search query');
          return;
        }

        setIsSearching(true);
        setLoading(true);
        setLoadingMessage('Searching Scryfall...');
        setSearchQuery(query);

        try {
          // Fetch cards using the search query
          const cards = await scryfall.current.fetchByQuery(query, 200);

          if (cards.length === 0) {
            setError('No cards found for this query. Try a different search.');
            setLoading(false);
            setIsSearching(false);
            return;
          }

          setCardPool(cards);
          setLoading(false);
          setIsSearching(false);
          nextQuestion();
        } catch (err) {
          setError(`Search failed: ${err.message}`);
          setLoading(false);
          setIsSearching(false);
        }
      };

      const handlePresetChange = async (presetKey) => {
        if (presetKey === activePreset) return;

        const preset = PRESET_DEFINITIONS[presetKey];

        // Update search field with preset query
        setSearchQuery(preset.query);

        // Mark as loading
        setLoadingPresets(prev => new Set(prev).add(presetKey));
        setLoading(true);
        setLoadingMessage(`Loading ${preset.label} cards...`);

        try {
          // Fetch preset pool (uses cache if available)
          const cards = await scryfall.current.fetchPresetPool(presetKey, false);

          // Update state
          setCardPool(cards);
          setActivePreset(presetKey);

          // Save to localStorage
          const meta = loadStorage(STORAGE_KEYS.CACHE_META, {});
          meta.activePreset = presetKey;
          saveStorage(STORAGE_KEYS.CACHE_META, meta);

          setLoading(false);
          nextQuestion(); // Generate new question from new pool
        } catch (err) {
          setError(`Failed to load ${presetKey}: ${err.message}`);
          setLoading(false);
        } finally {
          setLoadingPresets(prev => {
            const next = new Set(prev);
            next.delete(presetKey);
            return next;
          });
        }
      };

      // Custom mode handlers
      const handleConfigChange = useCallback((newConfig) => {
        setQuizConfig(newConfig);
      }, []);

      const handleModeToggle = useCallback(() => {
        const newMode = !customMode;
        setCustomMode(newMode);

        // If switching to custom mode, validate config
        if (newMode && cardPool) {
          const errors = validateQuizConfig(quizConfig, cardPool);
          setValidationErrors(errors);
        }

        // Generate new question for the new mode
        setTimeout(() => nextQuestion(), 100);
      }, [customMode, cardPool, quizConfig, nextQuestion]);

      const availableSets = cardPool ? [...new Set(cardPool.map(c => c.set))].sort() : [];

      if (loading) {
        return (
          <div className="app-container">
            <div className="loading">
              <div className="loading-spinner"></div>
              <div>{loadingMessage}</div>
              <div style={{ marginTop: 8, fontSize: '0.8rem' }}>This may take a few seconds...</div>
            </div>
          </div>
        );
      }

      if (error) {
        return (
          <div className="app-container">
            <div className="loading">
              <div style={{ color: 'var(--wrong)' }}>Error: {error}</div>
              <button className="refresh-btn" onClick={handleRefresh}>Retry</button>
            </div>
          </div>
        );
      }

      return (
        <div className="app-container">
          {streakPopup && <div className="streak-popup">{streakPopup} Streak!</div>}

          <div className="header">
            <h1>Card Knowledge Quiz</h1>
            <div className="subtitle">{cardPool.length} cards from {PRESET_DEFINITIONS[activePreset].label} ({availableSets.length} sets)</div>
            <div className="api-badge">Powered by Scryfall API â€” {PRESET_DEFINITIONS[activePreset].description}</div>
          </div>

          <ScoreBar score={score} />
          <SearchField
            query={searchQuery}
            onChange={setSearchQuery}
            onSearch={handleSearch}
          />
          <PresetToggleBar
            activePreset={activePreset}
            onPresetChange={handlePresetChange}
            loadingPresets={loadingPresets}
          />
          <FilterBar
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
          />

          {/* Mode Toggle Buttons */}
          <div style={{ marginBottom: '16px', display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
            <button
              className={`preset-btn ${!customMode ? 'active' : ''}`}
              onClick={() => !customMode || handleModeToggle()}
              style={{ flex: 'none' }}
            >
              ðŸŽ² Predefined Questions {!customMode && 'âœ“'}
            </button>

            {/* Question Type Filter (Predefined Mode Only) */}
            {!customMode && (
              <select
                className="filter-select"
                value={questionTypeFilter}
                onChange={(e) => setQuestionTypeFilter(e.target.value)}
                style={{ flex: 'none', maxWidth: '200px' }}
              >
                <option value="all">All Question Types</option>
                <option value="manaValue">Mana Value</option>
                <option value="powerToughness">Power/Toughness</option>
                <option value="color">Colors</option>
                <option value="cardType">Card Type</option>
                <option value="keywords">Keywords</option>
              </select>
            )}

            <button
              className={`preset-btn ${customMode ? 'active' : ''}`}
              onClick={() => customMode || handleModeToggle()}
              style={{ flex: 'none' }}
            >
              âš™ï¸ Custom Quiz {customMode && 'âœ“'}
            </button>
            {customMode && (
              <button
                className="preset-btn"
                onClick={() => setShowConfigPanel(!showConfigPanel)}
                style={{ flex: 'none' }}
              >
                {showConfigPanel ? 'Hide Config â–´' : 'Show Config â–¾'}
              </button>
            )}
            {customMode && validationErrors.length > 0 && (
              <span style={{ color: 'var(--wrong)', fontSize: '0.85rem' }}>
                âš ï¸ {validationErrors.length} error(s)
              </span>
            )}
          </div>

          {/* Custom Quiz Config Panel */}
          {customMode && showConfigPanel && (
            <QuizConfigPanel
              config={quizConfig}
              onConfigChange={handleConfigChange}
              cardPool={cardPool}
            />
          )}

          {currentQuestion && !showFeedback && (
            <div className="question-card">
              {/* Type badge */}
              {currentQuestion.type === 'custom' ? (
                <span className="question-type-badge badge-custom">
                  Custom: {FIELD_DEFINITIONS[currentQuestion.askFieldId]?.label}
                  {currentQuestion.difficulty > 0 && (
                    <span className={`difficulty-badge difficulty-${currentQuestion.difficulty}`}>
                      {DIFFICULTY_LABELS[currentQuestion.difficulty]}
                    </span>
                  )}
                </span>
              ) : (
                <span className={`question-type-badge ${QUESTION_TYPE_BADGES[currentQuestion.type]}`}>
                  {QUESTION_TYPE_LABELS[currentQuestion.type]}
                </span>
              )}

              {/* Question text */}
              {currentQuestion.type === 'custom' ? (
                <>
                  <div className="question-text">{currentQuestion.questionText}</div>
                  {currentQuestion.shownInfo && (
                    <div className="question-hint" style={{ marginBottom: '16px', fontSize: '1rem' }}>
                      {currentQuestion.shownInfo}
                    </div>
                  )}
                </>
              ) : (
                <>
                  <div className="question-text">
                    {currentQuestion.questionText}{' '}
                    <span className="card-name-highlight">{currentQuestion.card.name}</span>?
                  </div>
                  <div className="question-hint">{currentQuestion.hint}</div>
                </>
              )}

              {/* Answer inputs - predefined mode */}
              {currentQuestion.format === 'mc' && (
                <MultipleChoice
                  options={currentQuestion.options}
                  onSelect={handleMCSelect}
                  selectedIdx={selectedIdx}
                  disabled={selectedIdx !== null}
                />
              )}

              {currentQuestion.format === 'color' && (
                <ColorPicker
                  onSubmit={handleColorSubmit}
                  disabled={colorSubmitted}
                  correctColors={currentQuestion.correctColors}
                  submitted={colorSubmitted}
                  userColors={userColorAnswer}
                />
              )}

              {/* Answer inputs - custom mode */}
              {currentQuestion.type === 'custom' && currentQuestion.answerType === 'multipleChoice' && (
                <MultipleChoice
                  options={currentQuestion.options}
                  onSelect={handleMCSelect}
                  selectedIdx={selectedIdx}
                  disabled={selectedIdx !== null}
                />
              )}

              {currentQuestion.type === 'custom' && currentQuestion.answerType === 'colorPicker' && (
                <ColorPicker
                  onSubmit={handleColorSubmit}
                  disabled={colorSubmitted}
                  correctColors={currentQuestion.correctColors}
                  submitted={colorSubmitted}
                  userColors={userColorAnswer}
                />
              )}

              {currentQuestion.type === 'custom' && (currentQuestion.answerType === 'text' || currentQuestion.answerType === 'number') && (
                <AnswerInput
                  field={FIELD_DEFINITIONS[currentQuestion.askFieldId]}
                  question={currentQuestion}
                  onSubmit={(value) => {
                    const correct = currentQuestion.checkAnswer(value);
                    handleAnswer(correct, value);
                  }}
                  disabled={showFeedback}
                />
              )}
            </div>
          )}

          {!currentQuestion && !loading && (
            <div className="question-card" style={{ textAlign: 'center' }}>
              <div style={{ color: 'var(--text-muted)', padding: 20 }}>
                Not enough cards for these filters. Try broadening your selection.
              </div>
            </div>
          )}

          {showFeedback && currentQuestion && (
            <FeedbackSection
              question={currentQuestion}
              isCorrect={isCorrect}
              pointsEarned={pointsEarned}
              streakBonus={streakBonus}
              onNext={nextQuestion}
            />
          )}

          <div style={{ textAlign: 'center', marginTop: 24, paddingTop: 16, borderTop: '1px solid var(--border)' }}>
            <button className="refresh-btn" onClick={handleRefresh}>
              Refresh Card Pool (Fetch New Cards)
            </button>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CardKnowledgeQuiz />);
  </script>
</body>
</html>
