<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MTG Card Knowledge Quiz - Custom Mode</title>
  <style>
    /* ===== Base / Reset ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f0f13;
      --surface: #1a1a24;
      --surface-hover: #222233;
      --border: #2a2a3a;
      --text: #e0e0e8;
      --text-muted: #8888aa;
      --accent: #6c63ff;
      --accent-hover: #7f78ff;
      --correct: #22c55e;
      --correct-bg: rgba(34,197,94,0.12);
      --wrong: #ef4444;
      --wrong-bg: rgba(239,68,68,0.12);
      --gold: #f59e0b;
      --white-mana: #f9faf4;
      --blue-mana: #0e68ab;
      --black-mana: #150b00;
      --red-mana: #d3202a;
      --green-mana: #00733e;
      --colorless-mana: #9ea0a1;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }

    /* ===== LOCAL VERSION BANNER ===== */
    .local-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
      color: white;
      text-align: center;
      padding: 12px;
      font-weight: 900;
      font-size: 1.2rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5);
      border-bottom: 3px solid #7f1d1d;
    }
    .local-banner-spacer {
      height: 52px;
    }

    /* ===== Layout ===== */
    .app-container {
      max-width: 720px;
      margin: 0 auto;
      padding: 16px;
    }

    /* ===== Header ===== */
    .header {
      text-align: center;
      padding: 24px 0 16px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 20px;
    }
    .header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .header .subtitle {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-top: 4px;
    }
    .header .api-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      background: rgba(108,99,255,0.15);
      color: #9b94ff;
      margin-top: 6px;
    }

    /* ===== Score Bar ===== */
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 18px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 8px;
    }
    .score-item {
      text-align: center;
    }
    .score-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .score-value {
      font-size: 1.2rem;
      font-weight: 700;
    }
    .score-value.streak { color: var(--gold); }
    .score-value.accuracy { color: var(--accent); }

    /* ===== Filters ===== */
    .filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .filter-select {
      flex: 1;
      min-width: 120px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238888aa' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }
    .filter-select:hover { border-color: var(--accent); }

    /* ===== Preset Toggle Bar ===== */
    .preset-toggle-bar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .preset-primary {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      flex: 1;
    }

    .preset-btn {
      padding: 8px 16px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .preset-btn:hover:not(.active):not(:disabled) {
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .preset-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .preset-btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .spinner-mini {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ===== Search Field ===== */
    .search-field-container {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .search-input {
      flex: 1;
      min-width: 300px;
      padding: 10px 14px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.9rem;
      font-family: 'Courier New', monospace;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .search-btn {
      padding: 10px 20px;
      border: 2px solid var(--accent);
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .search-btn:hover {
      background: #5850e0;
      border-color: #5850e0;
    }

    .search-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      flex-basis: 100%;
      margin-top: -4px;
    }

    .search-hint a {
      color: var(--accent);
      text-decoration: none;
    }

    .search-hint a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      .search-input {
        min-width: 100%;
      }
      .search-btn {
        width: 100%;
      }
    }

    /* ===== Custom List ===== */
    .custom-list-container {
      margin-bottom: 16px;
    }

    .custom-list-textarea {
      width: 100%;
      padding: 10px 14px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.85rem;
      font-family: 'Segoe UI', sans-serif;
      resize: vertical;
      line-height: 1.5;
      box-sizing: border-box;
    }

    .custom-list-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .custom-list-textarea::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }

    /* ===== Config Panel ===== */
    .config-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .config-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .config-header h3 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent);
    }

    .config-toggle-btn {
      padding: 6px 14px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg);
      color: var(--text-muted);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .config-toggle-btn:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .field-config-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 16px;
    }

    .field-config-table th,
    .field-config-table td {
      padding: 12px 8px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .field-config-table th {
      background: rgba(108, 99, 255, 0.1);
      color: var(--accent);
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
    }

    .field-config-table input[type="checkbox"],
    .field-config-table input[type="radio"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    .field-config-table input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .difficulty-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .difficulty-0 { background: rgba(128, 128, 128, 0.2); color: #999; }
    .difficulty-1 { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .difficulty-2 { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .difficulty-3 { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
    .difficulty-4 { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .difficulty-5 { background: rgba(168, 85, 247, 0.2); color: #a855f7; }

    /* ===== Question Container ===== */
    .question-container {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 20px;
    }

    .question-type-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
      background: rgba(108, 99, 255, 0.15);
      color: var(--accent);
    }

    .question-text {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 20px;
      line-height: 1.4;
    }

    /* ===== Scryfall Card Display ===== */
    .scryfall-card-display {
      background: #171717;
      border: 1px solid #333;
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }

    .scryfall-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #333;
    }

    .scryfall-name {
      font-size: 1.2rem;
      font-weight: 700;
      color: #fff;
    }

    .scryfall-mana-cost {
      font-size: 1rem;
      font-family: 'Courier New', monospace;
      color: #aaa;
    }

    .scryfall-art {
      width: 50%;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .scryfall-type {
      font-size: 0.9rem;
      font-style: italic;
      color: #bbb;
      margin-bottom: 12px;
    }

    .scryfall-oracle {
      font-size: 0.95rem;
      line-height: 1.6;
      color: #ddd;
      margin-bottom: 12px;
      white-space: pre-wrap;
    }

    .scryfall-pt {
      text-align: right;
      font-size: 1.1rem;
      font-weight: 700;
      color: #fff;
    }

    .redacted {
      background: #555;
      color: transparent;
      border-radius: 4px;
      user-select: none;
      position: relative;
      display: inline-block;
    }

    .redacted::after {
      content: '█████';
      position: absolute;
      left: 0;
      color: #555;
    }

    /* ===== Answer Choices ===== */
    .answer-choices {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    @media (max-width: 480px) {
      .answer-choices {
        grid-template-columns: 1fr;
      }
    }

    .answer-btn {
      padding: 12px 16px;
      border: 2px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      text-align: center;
      position: relative;
      word-break: break-word;
    }

    .answer-btn:hover:not(:disabled) {
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .answer-btn:disabled {
      cursor: not-allowed;
    }

    .answer-btn.selected {
      border-color: var(--accent);
      background: rgba(108, 99, 255, 0.1);
    }

    .answer-btn.correct {
      border-color: var(--correct);
      background: var(--correct-bg);
    }

    .answer-btn.wrong {
      border-color: var(--wrong);
      background: var(--wrong-bg);
    }

    .answer-btn.short-answer {
      font-size: 1.5rem;
      font-weight: 700;
      padding: 16px 12px;
    }

    /* ===== Feedback ===== */
    .feedback {
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
    }

    .feedback.correct {
      border-color: var(--correct);
      background: var(--correct-bg);
    }

    .feedback.wrong {
      border-color: var(--wrong);
      background: var(--wrong-bg);
    }

    .feedback-header {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 12px;
    }

    .feedback.correct .feedback-header {
      color: var(--correct);
    }

    .feedback.wrong .feedback-header {
      color: var(--wrong);
    }

    .feedback-details {
      font-size: 0.95rem;
      color: var(--text);
      margin-bottom: 16px;
    }

    .next-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }

    .next-btn:hover {
      background: var(--accent-hover);
    }

    /* ===== Inline Feedback (replaces answer choices) ===== */
    .feedback-inline {
      margin-top: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    @media (min-width: 1000px) {
      .feedback-inline {
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        flex-wrap: wrap;
      }
    }

    .feedback-result {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 20px 24px;
      border-radius: 12px;
      width: 100%;
      max-width: 500px;
      border: 2px solid;
    }

    .feedback-result.correct {
      background: var(--correct-bg);
      border-color: var(--correct);
    }

    .feedback-result.wrong {
      background: var(--wrong-bg);
      border-color: var(--wrong);
    }

    .feedback-icon {
      font-size: 2.5rem;
      line-height: 1;
      font-weight: 900;
    }

    .feedback-result.correct .feedback-icon {
      color: var(--correct);
    }

    .feedback-result.wrong .feedback-icon {
      color: var(--wrong);
    }

    .feedback-text {
      flex: 1;
      color: var(--text);
    }

    .feedback-text strong {
      font-size: 1.1rem;
    }

    .full-card-reveal {
      max-width: 200px;
      width: 50%;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .full-card-reveal img {
      width: 100%;
      height: auto;
      display: block;
    }

    .next-btn-large {
      padding: 16px 48px;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(108, 99, 255, 0.3);
      width: 100%;
      max-width: 400px;
    }

    .next-btn-large:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(108, 99, 255, 0.4);
    }

    .next-btn-large:active {
      transform: translateY(0);
    }

    /* ===== Streak Popup ===== */
    .streak-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, var(--gold), #ff8800);
      color: #fff;
      padding: 32px 48px;
      border-radius: 16px;
      font-size: 2.5rem;
      font-weight: 900;
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.5);
      z-index: 10000;
      animation: popBounce 0.6s ease-out;
    }

    @keyframes popBounce {
      0% { transform: translate(-50%, -50%) scale(0); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* ===== Loading / Error States ===== */
    .loading-container {
      text-align: center;
      padding: 40px;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    .error-container {
      background: var(--wrong-bg);
      border: 2px solid var(--wrong);
      border-radius: 12px;
      padding: 24px;
      text-align: center;
    }

    .error-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--wrong);
      margin-bottom: 12px;
    }

    .error-message {
      font-size: 0.95rem;
      color: var(--text);
    }

    /* ===== Utility ===== */
    .text-center { text-align: center; }
    .mb-16 { margin-bottom: 16px; }
  </style>
</head>
<body>
  <div class="local-banner">LIVE VERSION</div>
  <div class="local-banner-spacer"></div>

  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    // ===================================================================
    // VERSION & CHANGELOG
    // ===================================================================
    /*
     * MTG Card Knowledge Quiz - Custom Mode Only
     * Version: 2.10.0
     * Last Updated: 2026-02-18 18:03 UTC
     *
     * CHANGELOG:
     * v2.10.0 (2026-02-18) - Prepopulated card lists
     *   - NEW: "Pauper" button loads a curated list of top Pauper format cards
     *   - Prepopulated lists show count and "Load Prepopulated List" button
     *   - Reusable system: add new lists by adding to PREPOPULATED_LISTS constant
     *   - List can be edited in textarea if needed
     *
     * v2.9.1 (2026-02-18) - Responsive card feedback layout
     *   - Card preview and feedback text now display side-by-side on wide screens (≥1000px)
     *   - Stacked vertically on mobile/narrow screens for better UX
     *   - Media query adjusts flex layout based on viewport width
     *
     * v2.9.0 (2026-02-18) - Custom card list feature ("My List")
     *   - NEW: "My List" button in preset bar lets you quiz on specific cards
     *   - Paste card names (one per line) into textarea, click "Load Cards"
     *   - Uses Scryfall /cards/collection API (batches of 75 for efficiency)
     *   - Shows which card names weren't found (in red)
     *   - List text persisted to localStorage across sessions
     *   - Search/filter UI hidden when in custom list mode
     *
     * v2.8.6 (2026-02-18) - Fix stale question when switching Ask field
     *   - BUG FIX: Switching settings showed previous config's question, not current
     *   - Root cause: pre-generated cache race condition — cache invalidation useEffect
     *     hadn't applied yet when nextQuestion useEffect ran, so stale cached question was used
     *   - Fix: validate cached question matches current askField/answerFormat before using it
     *
     * v2.8.5 (2026-02-16) - Fix Show checkboxes not matching card display
     *   - BUG FIX: Card display now uses live shownFields from config, not stale question snapshot
     *   - Toggling Show checkboxes instantly updates what's visible on the current card
     *   - Root cause: question object stored shownFields at generation time, never updated
     *
     * v2.8.4 (2026-02-16) - Fix "Next Question" button crash
     *   - BUG FIX: Added missing onNext prop to QuestionDisplay component
     *   - "Next Question" button was calling undefined function, causing crash after first answer
     *   - Now properly passes nextQuestion function as onNext prop
     *
     * v2.8.3 (2026-02-16) - Fix blank page after answering
     *   - BUG FIX: Added missing pointsEarned and streakBonus props to QuestionDisplay
     *   - Page was crashing due to undefined variable references in feedback display
     *   - Props now properly passed from CardKnowledgeQuiz to QuestionDisplay component
     *
     * v2.8.2 (2026-02-16) - Don't regenerate card when shownFields changes
     *   - BUG FIX: Toggling Show checkboxes no longer regenerates the question
     *   - Card only regenerates when: askField changes, answerFormat changes, or pool changes
     *   - Removed shownFields from useEffect dependencies (lines 2218, 2226)
     *   - More efficient: changing what's visible doesn't waste API calls or card pool queries
     *
     * v2.8.1 (2026-02-15) - Fix "show all" toggle (was backwards)
     *   - BUG FIX: Added missing canShow/canAsk properties to FIELD_CONFIG
     *   - "Show all fields (except asked)" now works correctly (was showing nothing when enabled)
     *   - Root cause: Filter checked FIELD_CONFIG[key].canShow but property didn't exist
     *
     * v2.8.0 (2026-02-15) - Inline feedback + full card reveal + "show all" toggle
     *   - Answer choices replaced with feedback after answering (no separate section)
     *   - Shows full card image on feedback (reveals all hidden fields)
     *   - Large "Next Question" button with auto-focus (press Enter or click)
     *   - NEW: "Show all fields (except asked)" toggle above field table
     *   - When enabled, automatically updates shown fields when Ask changes
     *   - Auto-checks old Ask field when switching to new Ask field
     *   - Manual checkbox changes disable "show all" toggle
     *   - Feedback shows checkmark/X icon + points earned or correct answer
     *   - Works for both Multiple Choice and Text Input modes
     *   - Better UX: click answer → see result + card → hit Enter for next
     *
     * v2.7.1 (2026-02-15) - Add background pre-generation for instant "Next Question"
     *   - Questions now pre-generate in background while user reviews feedback
     *   - Clicking "Next Question" is instant (uses cached pre-generated question)
     *   - Especially beneficial for Dynamic strategy (~1s API call happens in background)
     *   - Cache invalidated when config changes (askField, answerFormat, shownFields, strategy)
     *   - Flow: Answer → Show feedback → Pre-gen next in background → Click Next (instant!)
     *
     * v2.7.0 (2026-02-15) - Add dynamic API strategy (three-way toggle)
     *   - NEW: Three strategies for generating wrong answers
     *   - Strategy A (Pool): Search cached 200-card pool by similarity (instant, good quality)
     *   - Strategy B (Hierarchical): Filter cached pool by exact attributes (instant, harder)
     *   - Strategy C (Dynamic): Real-time Scryfall API queries for maximally similar cards (~1s, hardest)
     *   - Dynamic strategy makes hierarchical API queries (Level 1-6 relaxation)
     *   - Example Dynamic query: "type:creature color:B rarity:m is:legendary -mv:4"
     *   - Searches ALL Standard cards, not just cached pool
     *   - Type line parsing: supertypes (Legendary), card types (Creature), subtypes (Phyrexian)
     *   - Default: Pool (fast), toggle in config panel
     *
     * v2.6.0 (2026-02-15) - Add hierarchical wrong answer strategy (toggle)
     *   - NEW: Two strategies for generating wrong answers (user toggle in config)
     *   - Strategy A (Similarity): Score by similarity, walk down until 3 unique values
     *   - Strategy B (Hierarchical): Progressively relax constraints (color, rarity, supertypes, subtypes)
     *   - Hierarchical finds cards matching all attributes except askField → harder questions
     *   - Type line parsing: separates supertypes (Legendary), card types (Creature), subtypes (Phyrexian)
     *   - Default: Hierarchical (better quality), can switch to Similarity (faster)
     *
     * v2.5.1 (2026-02-15) - Optimize MC generation with early exit
     *   - Walk down similarity-sorted list until 3 unique values found
     *   - Early exit optimization: processes ~15 cards typically (not all 200)
     *   - Same quality (prioritizes similar wrong answers), faster performance
     *
     * v2.5.0 (2026-02-15) - Rewrite MC wrong answer generation (MAJOR FIX)
     *   - Now searches in decreasing similarity order for unique wrong answers
     *   - Was limited to top 20 most similar (failed when duplicates)
     *   - Guarantees maximum variety in answer choices
     *   - FIX: No longer fails when similar cards have duplicate values
     *   - Example: Asking for Mana Value now shows diverse options (1,3,5,7) not just (3,3,3,4)
     *
     * v2.4.0 (2026-02-15) - Default all fields shown + fix question generation
     *   - All showable fields now checked by default on first load
     *   - When selecting new Ask field, old Ask field automatically re-checked in Show
     *   - Relaxed multiple choice requirements: accepts 2-4 answer choices (was 4 only)
     *   - Reduced minimum pool size from 4 to 3 cards
     *   - Improved wrong answer variety (samples from 20 candidates instead of 10)
     *   - FIX: "Cannot generate questions" error for valid field combinations
     *
     * v2.3.0 (2026-02-15) - UI improvements and remove field restrictions
     *   - Moved Answer Format (Multiple Choice / Text Input) to top of config
     *   - Removed all incompatibility filtering (except can't show asked field)
     *   - Card Art field still viewable when checked in Show
     *   - Simplified field interactions
     *
     * v2.2.0 (2026-02-15) - Remove Card Image field
     *   - Removed cardImage field from config (full Scryfall card display)
     *   - Kept Card Art field (art_crop only)
     *   - Simplified to 7 fields total
     *   - Removed cardImage from incompatibleWith arrays
     *
     * v2.1.1 (2026-02-15) - Fix Show/Ask field behavior
     *   - FIX: Asking for a field now properly removes it from shown fields
     *   - FIX: Switching ask fields auto-toggles: old → shown, new → hidden
     *   - FIX: CardDisplay correctly filters out asked field
     *   - FIX: Asked field never appears in card display
     *
     * v2.1.0 (2026-02-15) - Custom-only version
     *   - Removed ALL predefined question code
     *   - Simplified to custom mode only
     *   - Kept all 8 field types with Scryfall card display
     *   - Kept preset system (Standard, Pioneer, Modern)
     *   - Kept similarity-based multiple choice
     *   - Kept auto-search and auto-generation
     */

    // ===================================================================
    // CONSTANTS
    // ===================================================================

    const SCRYFALL_API_BASE = 'https://api.scryfall.com';
    const SCRYFALL_DELAY = 100;

    const STORAGE_KEYS = {
      SCORE: 'card_quiz_score_v2',
      HISTORY: 'card_quiz_history_v2',
      CONFIG: 'card_quiz_custom_config',
    };

    const COLOR_MAP = {
      W: 'White',
      U: 'Blue',
      B: 'Black',
      R: 'Red',
      G: 'Green',
    };

    const DIFFICULTY_WEIGHTS = {
      0: 1,    // N/A
      1: 1,    // Easy
      2: 1.25, // Medium
      3: 1.5,  // Hard
      4: 2,    // Very Hard
      5: 2.5,  // Expert
    };

    const DIFFICULTY_LABELS = {
      0: 'N/A',
      1: 'Easy',
      2: 'Medium',
      3: 'Hard',
      4: 'Very Hard',
      5: 'Expert',
    };

    // Field configuration - all 8 field types
    const FIELD_CONFIG = {
      cardName: {
        id: 'cardName',
        label: 'Card Name',
        difficulty: 3,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.name,
        formatDisplay: (name) => name,
        incompatibleWith: [],
      },
      manaValue: {
        id: 'manaValue',
        label: 'Mana Value',
        difficulty: 2,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.manaValue,
        formatDisplay: (mv) => String(Math.floor(mv)),
        incompatibleWith: [],
      },
      colors: {
        id: 'colors',
        label: 'Colors',
        difficulty: 2,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.colors,
        formatDisplay: (colors) => colors.length ? colors.join('') : 'Colorless',
        incompatibleWith: [],
      },
      typeLine: {
        id: 'typeLine',
        label: 'Type Line',
        difficulty: 2,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.typeLine,
        formatDisplay: (tl) => tl,
        incompatibleWith: [],
      },
      powerToughness: {
        id: 'powerToughness',
        label: 'Power / Toughness',
        difficulty: 3,
        canShow: true,
        canAsk: true,
        requiresApplicability: true,
        checkApplicability: (pool) => pool.filter(c => c.isCreature && c.power && c.toughness).length >= 4,
        extractValue: (card) => `${card.power}/${card.toughness}`,
        formatDisplay: (pt) => pt,
        incompatibleWith: [],
      },
      oracleText: {
        id: 'oracleText',
        label: 'Text Box',
        difficulty: 4,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.oracleText || '',
        formatDisplay: (text) => text,
        incompatibleWith: ['cardArt'],
      },
      cardArt: {
        id: 'cardArt',
        label: 'Card Art',
        difficulty: 5,
        canShow: true,
        canAsk: true,
        requiresApplicability: false,
        extractValue: (card) => card.imageUris?.art_crop || '',
        formatDisplay: (url) => url,
        incompatibleWith: ['cardName'],
      },
    };

    const PRESET_DEFINITIONS = {
      standard: {
        label: 'Standard',
        query: 'format:standard game:paper -type:land',
        ttl: 7 * 24 * 60 * 60 * 1000,
        preCache: true,
      },
      pioneer: {
        label: 'Pioneer',
        query: 'format:pioneer game:paper -type:land',
        ttl: 30 * 24 * 60 * 60 * 1000,
        preCache: true,
      },
      modern: {
        label: 'Modern',
        query: 'format:modern game:paper -type:land',
        ttl: 30 * 24 * 60 * 60 * 1000,
        preCache: true,
      },
    };

    // Top Pauper cards for prepopulated lists
    const PREPOPULATED_LISTS = {
      pauper: {
        label: 'Pauper Top Cards',
        cards: [
          'Counterspell', 'Lightning Bolt', 'Murasa Rootgrazer', 'Spymaster\'s Snare', 'Thermopod',
          'Gorger Wurm', 'Kor Hookmaster', 'Stonehorn Dignitary', 'Akron Legionnaire', 'Pulse of Murasa',
          'Expedition Envoy', 'Silverblade Clerics', 'Priest of the Blessed Graph', 'Circle of Flame', 'Ash Barrens',
          'Disciple of Grace', 'Sunbaked Canyon', 'Obsidian Charmaw', 'Monastery Swiftspear', 'Tethered Griffin',
          'Patchwork Gnomes', 'Daze', 'Thought Scour', 'Ichor Wellspring', 'Archaeomancer',
          'Moment\'s Peace', 'Fissure', 'Deadly Dispute', 'Goblin Sharpshooter', 'Ephemerate',
          'Electryte', 'Frostghost', 'Slingerling', 'Cavern-Harpy', 'Anax, Hardened in the Forge',
          'Drunau Vampire', 'Void Snare', 'Dusky Crypt', 'Fanatic of Ruin', 'Night\'s Whisper',
          'Chainer\'s Torment', 'Dauthi Horror', 'Wrench Mind', 'Cast Down', 'Fanatic of Hazoret',
          'Goblin Gang Leader', 'Flame of Keld', 'Sedgemoor Witch', 'Seal of the Guildpact', 'Mystic Reflection'
        ]
      }
    };

    // ===================================================================
    // UTILITY FUNCTIONS
    // ===================================================================

    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function pickRandom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function formatColors(colors) {
      if (!colors || colors.length === 0) return 'Colorless';
      return colors.map(c => COLOR_MAP[c] || c).join(', ');
    }

    function colorsMatch(a, b) {
      if (!a || !b) return false;
      if (a.length !== b.length) return false;
      const sortedA = [...a].sort().join('');
      const sortedB = [...b].sort().join('');
      return sortedA === sortedB;
    }

    /**
     * Calculate similarity score between two cards
     * Higher score = more similar cards (better for wrong answers)
     */
    function cardSimilarity(card1, card2, excludeFieldId) {
      let score = 0;

      // Type Line similarity (highest weight) - unless testing typeLine
      if (excludeFieldId !== 'typeLine') {
        if (card1.typeLine === card2.typeLine) score += 10;
        else if (card1.typeLine && card2.typeLine) {
          const types1 = card1.typeLine.toLowerCase().split(/[\s—-]+/);
          const types2 = card2.typeLine.toLowerCase().split(/[\s—-]+/);
          const overlap = types1.filter(t => types2.includes(t)).length;
          score += overlap * 3;
        }
      }

      // Color identity match - unless testing colors
      if (excludeFieldId !== 'colors') {
        const colors1 = (card1.colors || []).sort().join('');
        const colors2 = (card2.colors || []).sort().join('');
        if (colors1 === colors2) score += 5;
      }

      // Mana value proximity - unless testing manaValue
      if (excludeFieldId !== 'manaValue') {
        const mvDiff = Math.abs((card1.manaValue || 0) - (card2.manaValue || 0));
        if (mvDiff === 0) score += 3;
        else if (mvDiff === 1) score += 2;
        else if (mvDiff === 2) score += 1;
      }

      // Power/Toughness similarity - unless testing powerToughness
      if (excludeFieldId !== 'powerToughness') {
        if (card1.isCreature && card2.isCreature) {
          if (card1.power === card2.power) score += 2;
          if (card1.toughness === card2.toughness) score += 2;
        }
      }

      return score;
    }

    /**
     * Redact card name from text (smart replacement)
     */
    function redactCardName(text, cardName) {
      if (!text || !cardName) return text;
      const pattern = new RegExp(cardName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      return text.replace(pattern, '[REDACTED]');
    }

    // ===================================================================
    // SCRYFALL API CLIENT
    // ===================================================================

    class ScryfallClient {
      constructor() {
        this.cache = new Map();
        this.lastRequestTime = 0;
      }

      async rateLimit() {
        const now = Date.now();
        const elapsed = now - this.lastRequestTime;
        if (elapsed < SCRYFALL_DELAY) {
          await new Promise(resolve => setTimeout(resolve, SCRYFALL_DELAY - elapsed));
        }
        this.lastRequestTime = Date.now();
      }

      getCacheKey(query) {
        return `scryfall_query_${query}`;
      }

      getCachedPool(key) {
        const cached = localStorage.getItem(this.getCacheKey(key));
        if (!cached) return null;

        try {
          const data = JSON.parse(cached);
          return data;
        } catch {
          return null;
        }
      }

      setCachedPool(key, cards) {
        try {
          const data = {
            cards,
            timestamp: Date.now(),
          };
          localStorage.setItem(this.getCacheKey(key), JSON.stringify(data));
        } catch (err) {
          console.error('Failed to cache pool:', err);
        }
      }

      isExpired(cachedData) {
        const ttl = 24 * 60 * 60 * 1000; // 24 hours default
        return Date.now() - cachedData.timestamp > ttl;
      }

      async fetchByQuery(query, limit = 50) {
        await this.rateLimit();

        const url = `${SCRYFALL_API_BASE}/cards/search?q=${encodeURIComponent(query)}&unique=cards&order=name`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`Scryfall API error: ${response.status}`);
        }

        const data = await response.json();
        const cards = data.data.slice(0, limit).map(this.normalizeCard);
        return cards;
      }

      /**
       * Fetch cards similar to a given card with progressive relaxation
       * Used for dynamic wrong answer generation
       */
      async fetchSimilarCards(correctCard, askField, excludeName) {
        const queries = this.buildSimilarityQueries(correctCard, askField, excludeName);

        const allCards = [];
        const seenNames = new Set();

        // Try each query level until we have enough cards
        for (const query of queries) {
          if (allCards.length >= 50) break; // Stop when we have enough

          try {
            const cards = await this.fetchByQuery(query, 20);

            // Deduplicate by card name
            for (const card of cards) {
              if (!seenNames.has(card.name)) {
                seenNames.add(card.name);
                allCards.push(card);
              }
            }
          } catch (err) {
            console.warn(`Query failed: ${query}`, err);
            continue; // Try next level
          }
        }

        return allCards;
      }

      /**
       * Build hierarchical queries from most to least specific
       */
      buildSimilarityQueries(card, askField, excludeName) {
        const queries = [];
        const type = parseTypeLine(card.typeLine);
        const colors = (card.colors || []).sort().join('');
        const rarity = card.rarity;
        const mv = card.manaValue;

        // Build color query part
        const colorQuery = colors ? `color:${colors}` : 'colorless';

        // Build type query parts
        const supertypeQuery = type.supertypes.length > 0
          ? type.supertypes.map(t => `type:${t}`).join(' ')
          : '';
        const cardTypeQuery = type.cardTypes.length > 0
          ? type.cardTypes.map(t => `type:${t}`).join(' ')
          : '';
        const subtypeQuery = type.subtypes.length > 0
          ? type.subtypes.map(t => `type:${t}`).join(' ')
          : '';

        // Base exclude (never include the correct card)
        const excludeQuery = `-name:"${excludeName}"`;

        // Also exclude the tested value (e.g., don't show cards with same MV)
        let excludeValueQuery = '';
        if (askField === 'manaValue') excludeValueQuery = `-mv:${mv}`;
        else if (askField === 'colors') excludeValueQuery = colors ? `-color:${colors}` : '';

        // Level 1: Everything matches except askField
        if (supertypeQuery && cardTypeQuery && subtypeQuery) {
          queries.push(`${colorQuery} ${supertypeQuery} ${cardTypeQuery} ${subtypeQuery} rarity:${rarity} ${excludeQuery} ${excludeValueQuery}`.trim());
        }

        // Level 2: Relax subtypes
        if (supertypeQuery && cardTypeQuery) {
          queries.push(`${colorQuery} ${supertypeQuery} ${cardTypeQuery} rarity:${rarity} ${excludeQuery} ${excludeValueQuery}`.trim());
        }

        // Level 3: Relax rarity
        if (supertypeQuery && cardTypeQuery) {
          queries.push(`${colorQuery} ${supertypeQuery} ${cardTypeQuery} ${excludeQuery} ${excludeValueQuery}`.trim());
        }

        // Level 4: Relax supertypes
        if (cardTypeQuery) {
          queries.push(`${colorQuery} ${cardTypeQuery} ${excludeQuery} ${excludeValueQuery}`.trim());
        }

        // Level 5: Relax colors
        if (cardTypeQuery) {
          queries.push(`${cardTypeQuery} ${excludeQuery} ${excludeValueQuery}`.trim());
        }

        // Level 6: Just exclude the correct card
        queries.push(excludeQuery);

        return queries;
      }

      async fetchPresetPool(presetKey, useCache = true) {
        const preset = PRESET_DEFINITIONS[presetKey];
        if (!preset) throw new Error(`Unknown preset: ${presetKey}`);

        // Check cache first
        if (useCache) {
          const cached = this.getCachedPool(presetKey);
          if (cached && !this.isExpired(cached)) {
            console.log(`Using cached ${presetKey} pool`);
            return cached.cards;
          }
        }

        // Fetch fresh
        console.log(`Fetching ${presetKey} pool from Scryfall...`);
        const cards = await this.fetchByQuery(preset.query, 100);

        // Cache result
        this.setCachedPool(presetKey, cards);

        return cards;
      }

      async fetchByNames(names) {
        const BATCH_SIZE = 75;
        const allFound = [];
        const allNotFound = [];

        for (let i = 0; i < names.length; i += BATCH_SIZE) {
          await this.rateLimit();
          const batch = names.slice(i, i + BATCH_SIZE);
          const identifiers = batch.map(name => ({ name }));

          const response = await fetch(`${SCRYFALL_API_BASE}/cards/collection`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ identifiers }),
          });

          if (!response.ok) {
            throw new Error(`Scryfall collection API error: ${response.status}`);
          }

          const data = await response.json();
          allFound.push(...(data.data || []).map(card => this.normalizeCard(card)));
          allNotFound.push(...(data.not_found || []).map(nf => nf.name));
        }

        return { found: allFound, notFound: allNotFound };
      }

      normalizeCard(raw) {
        return {
          name: raw.name,
          manaValue: raw.cmc || 0,
          colors: raw.colors || [],
          colorIdentity: raw.color_identity || [],
          typeLine: raw.type_line || '',
          oracleText: raw.oracle_text || '',
          power: raw.power,
          toughness: raw.toughness,
          isCreature: (raw.type_line || '').includes('Creature'),
          imageUris: raw.image_uris || {},
          scryfallUri: raw.scryfall_uri,
        };
      }
    }

    // ===================================================================
    // QUESTION GENERATION - CUSTOM MODE
    // ===================================================================

    function getApplicableCards(cardPool, config) {
      const { askField } = config;
      const fieldDef = FIELD_CONFIG[askField];

      if (!fieldDef) return cardPool;

      // If field requires applicability check, filter pool
      if (fieldDef.requiresApplicability && fieldDef.checkApplicability) {
        return cardPool.filter(c => {
          if (askField === 'powerToughness') {
            return c.isCreature && c.power && c.toughness;
          }
          return true;
        });
      }

      return cardPool;
    }

    function validateQuizConfig(config, cardPool) {
      const errors = [];

      if (!config.askField) {
        errors.push('No "Ask" field selected');
      }

      if (config.shownFields.length === 0) {
        errors.push('At least one field must be shown');
      }

      // Check if enough applicable cards (need 3 minimum: 1 correct + 2 wrong)
      const applicable = getApplicableCards(cardPool, config);
      if (applicable.length < 3) {
        errors.push(`Not enough cards for selected field (need 3, found ${applicable.length})`);
      }

      return errors;
    }

    async function generateCustomQuestion(cardPool, config, scryfallClient) {
      if (!cardPool || cardPool.length < 2) return null;
      if (!config.askField) return null;

      const applicableCards = getApplicableCards(cardPool, config);
      // Text input only needs 1 card, MC needs at least 3 (1 correct + 2 unique wrong values)
      // Exception: dynamic strategy can work with any pool size (fetches from API)
      const minRequired = config.answerFormat === 'multipleChoice' && config.wrongAnswerStrategy !== 'dynamic' ? 3 : 1;
      if (applicableCards.length < minRequired) return null;

      const correctCard = pickRandom(applicableCards);
      const fieldDef = FIELD_CONFIG[config.askField];

      // Extract correct answer
      const correctValue = fieldDef.extractValue(correctCard);
      const correctDisplay = fieldDef.formatDisplay(correctValue);

      // Build question based on answer format
      if (config.answerFormat === 'multipleChoice') {
        return await generateMultipleChoiceQuestion(correctCard, applicableCards, config, fieldDef, correctDisplay, scryfallClient);
      } else if (config.answerFormat === 'textInput') {
        return generateTextInputQuestion(correctCard, config, fieldDef, correctDisplay);
      }

      return null;
    }

    /**
     * Parse type line into components
     * "Legendary Creature — Phyrexian Praetor" → {supertypes: ["Legendary"], cardTypes: ["Creature"], subtypes: ["Phyrexian", "Praetor"]}
     */
    function parseTypeLine(typeLine) {
      if (!typeLine) return { supertypes: [], cardTypes: [], subtypes: [] };

      const [mainPart, subtypePart] = typeLine.split(/\s*[—–-]\s*/);
      const mainTypes = mainPart.trim().split(/\s+/);

      const SUPERTYPES = ['Legendary', 'Snow', 'Basic', 'World', 'Ongoing'];
      const CARD_TYPES = ['Creature', 'Artifact', 'Enchantment', 'Planeswalker', 'Instant', 'Sorcery', 'Land', 'Tribal', 'Battle'];

      const supertypes = mainTypes.filter(t => SUPERTYPES.includes(t));
      const cardTypes = mainTypes.filter(t => CARD_TYPES.includes(t));
      const subtypes = subtypePart ? subtypePart.trim().split(/\s+/) : [];

      return { supertypes, cardTypes, subtypes };
    }

    /**
     * Strategy A: Similarity-based (fast, simpler)
     * Score all cards by similarity, walk down list until 3 unique values found
     */
    function generateMCBySimilarity(correctCard, pool, config, fieldDef, correctDisplay) {
      // Score all cards by similarity (once)
      const scoredCards = pool
        .filter(c => c.name !== correctCard.name)
        .map(c => ({
          card: c,
          similarity: cardSimilarity(c, correctCard, config.askField),
        }))
        .sort((a, b) => b.similarity - a.similarity);

      // Walk down similarity-sorted list until 3 unique values found
      const uniqueWrongValues = new Set();
      const wrongAnswers = [];

      for (const { card } of scoredCards) {
        if (wrongAnswers.length >= 3) break;

        const value = fieldDef.extractValue(card);
        const display = fieldDef.formatDisplay(value);

        // Skip if same as correct answer or already used
        if (display === correctDisplay || uniqueWrongValues.has(display)) continue;

        uniqueWrongValues.add(display);
        wrongAnswers.push(display);
      }

      return wrongAnswers.length >= 2 ? wrongAnswers : null;
    }

    /**
     * Strategy B: Dynamic API queries (searches all cards, not just pool)
     * Makes real-time Scryfall queries for maximally similar cards
     */
    async function generateMCByDynamicAPI(correctCard, scryfallClient, config, fieldDef, correctDisplay) {
      // Fetch similar cards from Scryfall API
      const similarCards = await scryfallClient.fetchSimilarCards(correctCard, config.askField, correctCard.name);

      if (similarCards.length < 3) {
        console.warn('Not enough similar cards found via API');
        return null;
      }

      // Extract unique wrong values
      const uniqueWrongValues = new Set();
      const wrongAnswers = [];

      for (const card of similarCards) {
        if (wrongAnswers.length >= 3) break;

        const value = fieldDef.extractValue(card);
        const display = fieldDef.formatDisplay(value);

        // Skip if same as correct answer or already used
        if (display === correctDisplay || uniqueWrongValues.has(display)) continue;

        uniqueWrongValues.add(display);
        wrongAnswers.push(display);
      }

      return wrongAnswers.length >= 2 ? wrongAnswers : null;
    }

    /**
     * Strategy C: Hierarchical filtering within pool (filters cached 200 cards)
     * Progressively relax constraints until enough unique wrong answers found
     */
    function generateMCByHierarchy(correctCard, pool, config, fieldDef, correctDisplay) {
      const askField = config.askField;
      const otherCards = pool.filter(c => c.name !== correctCard.name);

      // Parse correct card's attributes
      const correctColors = (correctCard.colors || []).sort().join('');
      const correctRarity = correctCard.rarity;
      const correctType = parseTypeLine(correctCard.typeLine);

      // Define relaxation levels (in order of specificity)
      const relaxationLevels = [
        // Level 1: Everything matches except askField (most specific)
        (card) => {
          const cardColors = (card.colors || []).sort().join('');
          const cardType = parseTypeLine(card.typeLine);

          return cardColors === correctColors &&
                 card.rarity === correctRarity &&
                 cardType.supertypes.sort().join('') === correctType.supertypes.sort().join('') &&
                 cardType.cardTypes.sort().join('') === correctType.cardTypes.sort().join('') &&
                 cardType.subtypes.sort().join('') === correctType.subtypes.sort().join('');
        },

        // Level 2: Relax subtypes (high variance)
        (card) => {
          const cardColors = (card.colors || []).sort().join('');
          const cardType = parseTypeLine(card.typeLine);

          return cardColors === correctColors &&
                 card.rarity === correctRarity &&
                 cardType.supertypes.sort().join('') === correctType.supertypes.sort().join('') &&
                 cardType.cardTypes.sort().join('') === correctType.cardTypes.sort().join('');
        },

        // Level 3: Relax rarity (medium variance)
        (card) => {
          const cardColors = (card.colors || []).sort().join('');
          const cardType = parseTypeLine(card.typeLine);

          return cardColors === correctColors &&
                 cardType.supertypes.sort().join('') === correctType.supertypes.sort().join('') &&
                 cardType.cardTypes.sort().join('') === correctType.cardTypes.sort().join('');
        },

        // Level 4: Relax supertypes
        (card) => {
          const cardColors = (card.colors || []).sort().join('');
          const cardType = parseTypeLine(card.typeLine);

          return cardColors === correctColors &&
                 cardType.cardTypes.sort().join('') === correctType.cardTypes.sort().join('');
        },

        // Level 5: Relax colors (low variance - clusters heavily)
        (card) => {
          const cardType = parseTypeLine(card.typeLine);
          return cardType.cardTypes.sort().join('') === correctType.cardTypes.sort().join('');
        },

        // Level 6: Any card in pool (broadest)
        (card) => true,
      ];

      const uniqueWrongValues = new Set();
      const wrongAnswers = [];

      // Try each relaxation level until we have 3 unique wrong answers
      for (const filterFn of relaxationLevels) {
        if (wrongAnswers.length >= 3) break;

        const candidates = otherCards.filter(filterFn);

        // Extract unique values from this level
        for (const card of candidates) {
          if (wrongAnswers.length >= 3) break;

          const value = fieldDef.extractValue(card);
          const display = fieldDef.formatDisplay(value);

          // Skip if same as correct answer or already used
          if (display === correctDisplay || uniqueWrongValues.has(display)) continue;

          uniqueWrongValues.add(display);
          wrongAnswers.push(display);
        }
      }

      return wrongAnswers.length >= 2 ? wrongAnswers : null;
    }

    /**
     * Main MC question generator - routes to appropriate strategy
     */
    async function generateMultipleChoiceQuestion(correctCard, pool, config, fieldDef, correctDisplay, scryfallClient) {
      const strategy = config.wrongAnswerStrategy || 'pool';

      let wrongAnswers;
      if (strategy === 'dynamic') {
        wrongAnswers = await generateMCByDynamicAPI(correctCard, scryfallClient, config, fieldDef, correctDisplay);
      } else if (strategy === 'hierarchical') {
        wrongAnswers = generateMCByHierarchy(correctCard, pool, config, fieldDef, correctDisplay);
      } else {
        wrongAnswers = generateMCBySimilarity(correctCard, pool, config, fieldDef, correctDisplay);
      }

      if (!wrongAnswers || wrongAnswers.length < 2) return null;

      const choices = shuffle([correctDisplay, ...wrongAnswers]);

      return {
        type: 'custom',
        card: correctCard,
        questionText: `What is the ${fieldDef.label} of this card?`,
        choices,
        correctAnswer: correctDisplay,
        answerFormat: 'multipleChoice',
        shownFields: config.shownFields,
        askField: config.askField,
        difficulty: fieldDef.difficulty,
      };
    }

    function generateTextInputQuestion(correctCard, config, fieldDef, correctDisplay) {
      return {
        type: 'custom',
        card: correctCard,
        questionText: `What is the ${fieldDef.label} of this card?`,
        correctAnswer: correctDisplay,
        answerFormat: 'textInput',
        shownFields: config.shownFields,
        askField: config.askField,
        difficulty: fieldDef.difficulty,
      };
    }

    // ===================================================================
    // STORAGE
    // ===================================================================

    function loadStorage(key, defaultValue) {
      try {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      } catch {
        return defaultValue;
      }
    }

    function saveStorage(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch (err) {
        console.error('Failed to save to localStorage:', err);
      }
    }

    // ===================================================================
    // REACT COMPONENTS
    // ===================================================================

    function PresetSelector({ activePreset, onSelect, loading }) {
      const presets = ['standard', 'pioneer', 'modern'];

      return (
        <div className="preset-toggle-bar">
          <div className="preset-primary">
            {presets.map(key => {
              const preset = PRESET_DEFINITIONS[key];
              const isActive = activePreset === key;
              const isLoading = loading === key;

              return (
                <button
                  key={key}
                  className={`preset-btn ${isActive ? 'active' : ''}`}
                  onClick={() => onSelect(key)}
                  disabled={isLoading}
                >
                  {isLoading && <span className="spinner-mini" />}
                  {preset.label}
                </button>
              );
            })}
            <button
              className={`preset-btn ${activePreset === 'customList' ? 'active' : ''}`}
              onClick={() => onSelect('customList')}
              disabled={loading === 'customList'}
            >
              {loading === 'customList' && <span className="spinner-mini" />}
              My List
            </button>
            <button
              className={`preset-btn ${activePreset === 'pauper' ? 'active' : ''}`}
              onClick={() => onSelect('pauper')}
              disabled={loading === 'pauper'}
            >
              {loading === 'pauper' && <span className="spinner-mini" />}
              Pauper
            </button>
          </div>
        </div>
      );
    }

    function SearchField({ value, onChange, onSearch }) {
      return (
        <div className="search-field-container">
          <input
            type="text"
            className="search-input"
            placeholder="format:standard type:creature"
            value={value}
            onChange={(e) => onChange(e.target.value)}
          />
          <button className="search-btn" onClick={() => onSearch(value)}>
            Search
          </button>
          <div className="search-hint">
            Use <a href="https://scryfall.com/docs/syntax" target="_blank" rel="noopener">Scryfall syntax</a>
          </div>
        </div>
      );
    }

    function CustomListInput({ value, onChange, onLoad, onLoadPrepopulated, loading, notFound, activePreset }) {
      const isPrepopulated = activePreset !== 'customList';

      return (
        <div className="custom-list-container">
          {!isPrepopulated && (
            <>
              <textarea
                className="custom-list-textarea"
                placeholder={"Enter card names, one per line:\nLightning Bolt\nCounterspell\nSwords to Plowshares"}
                value={value}
                onChange={(e) => onChange(e.target.value)}
                rows={8}
              />
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginTop: '8px' }}>
                <button
                  className="search-btn"
                  onClick={onLoad}
                  disabled={loading || !value.trim()}
                >
                  {loading ? 'Loading...' : 'Load Cards'}
                </button>
                <span style={{ fontSize: '0.8rem', color: 'var(--text-muted)' }}>
                  {value.trim() ? `${value.trim().split('\n').filter(l => l.trim()).length} names entered` : ''}
                </span>
              </div>
            </>
          )}
          {isPrepopulated && (
            <div style={{ padding: '12px', background: 'var(--surface)', borderRadius: '8px', marginBottom: '8px' }}>
              <div style={{ fontSize: '0.9rem', color: 'var(--text-muted)', marginBottom: '8px' }}>
                {Object.values(PREPOPULATED_LISTS).find(l => l.label.toLowerCase().includes(activePreset))?.cards.length || 0} cards selected
              </div>
              <button
                className="search-btn"
                onClick={() => onLoadPrepopulated(activePreset)}
                disabled={loading}
              >
                {loading ? 'Loading...' : 'Load Prepopulated List'}
              </button>
            </div>
          )}
          {notFound && notFound.length > 0 && (
            <div style={{
              marginTop: '8px',
              padding: '8px 12px',
              background: 'rgba(239, 68, 68, 0.1)',
              border: '1px solid rgba(239, 68, 68, 0.3)',
              borderRadius: '8px',
              fontSize: '0.8rem',
            }}>
              <div style={{ color: '#ef4444', fontWeight: 600, marginBottom: '4px' }}>
                Not found ({notFound.length}):
              </div>
              <div style={{ color: '#f87171' }}>
                {notFound.join(', ')}
              </div>
            </div>
          )}
        </div>
      );
    }

    function FilterBar({ colorFilter, rarityFilter, onColorChange, onRarityChange }) {
      return (
        <div className="filters">
          <select className="filter-select" value={colorFilter} onChange={(e) => onColorChange(e.target.value)}>
            <option value="">All Colors</option>
            <option value="W">White</option>
            <option value="U">Blue</option>
            <option value="B">Black</option>
            <option value="R">Red</option>
            <option value="G">Green</option>
            <option value="C">Colorless</option>
          </select>
          <select className="filter-select" value={rarityFilter} onChange={(e) => onRarityChange(e.target.value)}>
            <option value="">All Rarities</option>
            <option value="common">Common</option>
            <option value="uncommon">Uncommon</option>
            <option value="rare">Rare</option>
            <option value="mythic">Mythic</option>
          </select>
        </div>
      );
    }

    function ConfigPanel({ config, onConfigChange, cardPool }) {
      const [collapsed, setCollapsed] = useState(false);

      const handleShowToggle = (fieldId) => {
        const isShown = config.shownFields.includes(fieldId);
        const newShownFields = isShown
          ? config.shownFields.filter(f => f !== fieldId)
          : [...config.shownFields, fieldId];

        // Disable "show all except asked" when manually toggling individual fields
        onConfigChange({ ...config, shownFields: newShownFields, showAllExceptAsked: false });
      };

      const handleAskChange = (fieldId) => {
        let newShownFields;

        // If "show all except asked" is enabled, update to show all except new askField
        if (config.showAllExceptAsked) {
          newShownFields = Object.keys(FIELD_CONFIG)
            .filter(key => FIELD_CONFIG[key].canShow && key !== fieldId);
        } else {
          // Otherwise, just remove new askField from shownFields, add old askField to shownFields
          newShownFields = config.shownFields.filter(f => f !== fieldId);
          const oldAskField = config.askField;

          // Add old asked field back to shown (if it exists and can be shown)
          if (oldAskField && FIELD_CONFIG[oldAskField]?.canShow && !newShownFields.includes(oldAskField)) {
            newShownFields.push(oldAskField);
          }
        }

        onConfigChange({
          ...config,
          askField: fieldId,
          shownFields: newShownFields
        });
      };

      const isFieldDisabled = (fieldId, mode) => {
        if (mode === 'show') {
          // Can't show the field you're asking about
          if (fieldId === config.askField) return true;
        }

        // No other restrictions
        return false;
      };

      const errors = validateQuizConfig(config, cardPool);

      return (
        <div className="config-panel">
          <div className="config-header">
            <h3>Quiz Configuration</h3>
            <button className="config-toggle-btn" onClick={() => setCollapsed(!collapsed)}>
              {collapsed ? 'Show' : 'Hide'}
            </button>
          </div>

          {!collapsed && (
            <>
              <div style={{ marginBottom: '16px' }}>
                <label style={{ fontSize: '0.9rem', color: 'var(--text-muted)', fontWeight: '600' }}>
                  Answer Format:
                </label>
                <div style={{ display: 'flex', gap: '16px', marginTop: '8px' }}>
                  <label>
                    <input
                      type="radio"
                      name="answerFormat"
                      value="multipleChoice"
                      checked={config.answerFormat === 'multipleChoice'}
                      onChange={() => onConfigChange({ ...config, answerFormat: 'multipleChoice' })}
                    />
                    {' '}Multiple Choice
                  </label>
                  <label>
                    <input
                      type="radio"
                      name="answerFormat"
                      value="textInput"
                      checked={config.answerFormat === 'textInput'}
                      onChange={() => onConfigChange({ ...config, answerFormat: 'textInput' })}
                    />
                    {' '}Text Input
                  </label>
                </div>
              </div>

              {config.answerFormat === 'multipleChoice' && (
                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '0.9rem', color: 'var(--text-muted)', fontWeight: '600' }}>
                    Wrong Answer Strategy:
                  </label>
                  <div style={{ display: 'flex', gap: '16px', marginTop: '8px', flexWrap: 'wrap' }}>
                    <label>
                      <input
                        type="radio"
                        name="wrongAnswerStrategy"
                        value="pool"
                        checked={config.wrongAnswerStrategy === 'pool' || !config.wrongAnswerStrategy}
                        onChange={() => onConfigChange({ ...config, wrongAnswerStrategy: 'pool' })}
                      />
                      {' '}Pool (fast)
                    </label>
                    <label>
                      <input
                        type="radio"
                        name="wrongAnswerStrategy"
                        value="hierarchical"
                        checked={config.wrongAnswerStrategy === 'hierarchical'}
                        onChange={() => onConfigChange({ ...config, wrongAnswerStrategy: 'hierarchical' })}
                      />
                      {' '}Hierarchical
                    </label>
                    <label>
                      <input
                        type="radio"
                        name="wrongAnswerStrategy"
                        value="dynamic"
                        checked={config.wrongAnswerStrategy === 'dynamic'}
                        onChange={() => onConfigChange({ ...config, wrongAnswerStrategy: 'dynamic' })}
                      />
                      {' '}Dynamic (hardest)
                    </label>
                  </div>
                  <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginTop: '4px' }}>
                    <strong>Pool:</strong> Searches cached cards by similarity (instant, good quality)
                    <br />
                    <strong>Hierarchical:</strong> Filters cached cards by exact attributes (instant, harder)
                    <br />
                    <strong>Dynamic:</strong> Queries Scryfall API for maximally similar cards (~1s delay, hardest questions)
                  </div>
                </div>
              )}

              <div style={{ marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                <label style={{ fontSize: '0.9rem', color: 'var(--text-muted)', fontWeight: '600', cursor: 'pointer' }}>
                  <input
                    type="checkbox"
                    checked={config.showAllExceptAsked || false}
                    onChange={(e) => {
                      const showAll = e.target.checked;
                      if (showAll) {
                        // Show all fields except the asked one
                        const allFieldsExceptAsked = Object.keys(FIELD_CONFIG)
                          .filter(key => FIELD_CONFIG[key].canShow && key !== config.askField);
                        onConfigChange({ ...config, showAllExceptAsked: true, shownFields: allFieldsExceptAsked });
                      } else {
                        onConfigChange({ ...config, showAllExceptAsked: false });
                      }
                    }}
                  />
                  {' '}Show all fields (except asked)
                </label>
              </div>

              <table className="field-config-table">
                <thead>
                  <tr>
                    <th>Field</th>
                    <th>Show</th>
                    <th>Ask</th>
                    <th>Difficulty</th>
                  </tr>
                </thead>
                <tbody>
                  {Object.values(FIELD_CONFIG).map(field => (
                    <tr key={field.id}>
                      <td>{field.label}</td>
                      <td>
                        <input
                          type="checkbox"
                          checked={config.shownFields.includes(field.id)}
                          onChange={() => handleShowToggle(field.id)}
                          disabled={isFieldDisabled(field.id, 'show')}
                        />
                      </td>
                      <td>
                        <input
                          type="radio"
                          name="askField"
                          checked={config.askField === field.id}
                          onChange={() => handleAskChange(field.id)}
                          disabled={isFieldDisabled(field.id, 'ask')}
                        />
                      </td>
                      <td>
                        <span className={`difficulty-badge difficulty-${field.difficulty}`}>
                          {DIFFICULTY_LABELS[field.difficulty]}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>

              {errors.length > 0 && (
                <div style={{
                  marginTop: '16px',
                  padding: '12px',
                  background: 'var(--wrong-bg)',
                  border: '1px solid var(--wrong)',
                  borderRadius: '8px',
                  fontSize: '0.9rem',
                }}>
                  {errors.map((err, idx) => (
                    <div key={idx} style={{ color: 'var(--wrong)' }}>⚠️ {err}</div>
                  ))}
                </div>
              )}
            </>
          )}
        </div>
      );
    }

    function ScryfallCardDisplay({ card, shownFields, askField }) {
      // Filter out the asked field from what should be shown
      const actualShownFields = shownFields.filter(f => f !== askField);

      // Determine what to show (must be in shownFields AND not the askField)
      const shouldShowName = actualShownFields.includes('cardName');
      const shouldShowMV = actualShownFields.includes('manaValue');
      const shouldShowType = actualShownFields.includes('typeLine');
      const shouldShowText = actualShownFields.includes('oracleText');
      const shouldShowPT = actualShownFields.includes('powerToughness') && card.isCreature;
      const shouldShowArt = actualShownFields.includes('cardArt');

      // Redact card name if asking for name OR if asking for text
      const shouldRedactNameInText = askField === 'cardName' || askField === 'oracleText';

      let displayText = card.oracleText || '';
      if (shouldRedactNameInText && card.name) {
        displayText = redactCardName(displayText, card.name);
      }

      return (
        <div className="scryfall-card-display">
          <div className="scryfall-header">
            <div className={`scryfall-name ${!shouldShowName ? 'redacted' : ''}`}>
              {!shouldShowName ? '[REDACTED]' : card.name}
            </div>
            {shouldShowMV && (
              <div className="scryfall-mana-cost">
                {Math.floor(card.manaValue)}
              </div>
            )}
          </div>

          {shouldShowArt && card.imageUris?.art_crop && (
            <img
              src={card.imageUris.art_crop}
              alt="Card art"
              className="scryfall-art"
            />
          )}

          {shouldShowType && (
            <div className="scryfall-type">{card.typeLine}</div>
          )}

          {shouldShowText && (
            <div className="scryfall-oracle">
              {displayText}
            </div>
          )}

          {shouldShowPT && (
            <div className="scryfall-pt">
              {card.power}/{card.toughness}
            </div>
          )}
        </div>
      );
    }

    function QuestionDisplay({ question, onAnswer, showFeedback, isCorrect, selectedIdx, pointsEarned, streakBonus, onNext, liveShownFields }) {
      const [textAnswer, setTextAnswer] = useState('');

      const handleChoice = (idx) => {
        if (showFeedback) return;
        const choice = question.choices[idx];
        onAnswer(choice === question.correctAnswer, choice);
      };

      const handleTextSubmit = () => {
        if (showFeedback || !textAnswer.trim()) return;
        const correct = textAnswer.trim().toLowerCase() === question.correctAnswer.toLowerCase();
        onAnswer(correct, textAnswer);
      };

      return (
        <div className="question-container">
          <div className="question-type-badge">
            Custom Question
          </div>

          <div className="question-text">
            {question.questionText}
          </div>

          <ScryfallCardDisplay
            card={question.card}
            shownFields={liveShownFields || question.shownFields}
            askField={question.askField}
          />

          {!showFeedback && question.answerFormat === 'multipleChoice' && (
            <div className="answer-choices">
              {question.choices.map((choice, idx) => {
                let className = 'answer-btn';
                if (idx === selectedIdx) {
                  className += ' selected';
                }
                // Add class for single character or number
                if (choice && choice.length <= 2 && /^[A-Z0-9]/.test(choice)) {
                  className += ' short-answer';
                }

                return (
                  <button
                    key={idx}
                    className={className}
                    onClick={() => handleChoice(idx)}
                  >
                    {choice}
                  </button>
                );
              })}
            </div>
          )}

          {showFeedback && question.answerFormat === 'multipleChoice' && (
            <div className="feedback-inline">
              <div className={`feedback-result ${isCorrect ? 'correct' : 'wrong'}`}>
                <div className="feedback-icon">
                  {isCorrect ? '✓' : '✗'}
                </div>
                <div className="feedback-text">
                  {isCorrect ? (
                    <div>
                      <strong>Correct!</strong>
                      <div style={{ fontSize: '0.9rem', marginTop: '4px' }}>
                        +{pointsEarned} points (×{streakBonus.toFixed(1)} streak bonus)
                      </div>
                    </div>
                  ) : (
                    <div>
                      <strong>Incorrect</strong>
                      <div style={{ fontSize: '0.9rem', marginTop: '4px' }}>
                        Correct answer: <strong>{question.correctAnswer}</strong>
                      </div>
                    </div>
                  )}
                </div>
              </div>
              {question.card.imageUris?.normal && (
                <div className="full-card-reveal">
                  <img src={question.card.imageUris.normal} alt={question.card.name} />
                </div>
              )}
              <button className="next-btn-large" onClick={onNext} autoFocus>
                Next Question →
              </button>
            </div>
          )}

          {!showFeedback && question.answerFormat === 'textInput' && (
            <div style={{ marginTop: '20px' }}>
              <input
                type="text"
                className="search-input"
                placeholder="Type your answer..."
                value={textAnswer}
                onChange={(e) => setTextAnswer(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && handleTextSubmit()}
                style={{ width: '100%', marginBottom: '12px' }}
              />
              <button
                className="search-btn"
                onClick={handleTextSubmit}
                disabled={!textAnswer.trim()}
                style={{ width: '100%' }}
              >
                Submit
              </button>
            </div>
          )}

          {showFeedback && question.answerFormat === 'textInput' && (
            <div className="feedback-inline">
              <div className={`feedback-result ${isCorrect ? 'correct' : 'wrong'}`}>
                <div className="feedback-icon">
                  {isCorrect ? '✓' : '✗'}
                </div>
                <div className="feedback-text">
                  {isCorrect ? (
                    <div>
                      <strong>Correct!</strong>
                      <div style={{ fontSize: '0.9rem', marginTop: '4px' }}>
                        +{pointsEarned} points (×{streakBonus.toFixed(1)} streak bonus)
                      </div>
                    </div>
                  ) : (
                    <div>
                      <strong>Incorrect</strong>
                      <div style={{ fontSize: '0.9rem', marginTop: '4px' }}>
                        Correct answer: <strong>{question.correctAnswer}</strong>
                      </div>
                    </div>
                  )}
                </div>
              </div>
              {question.card.imageUris?.normal && (
                <div className="full-card-reveal">
                  <img src={question.card.imageUris.normal} alt={question.card.name} />
                </div>
              )}
              <button className="next-btn-large" onClick={onNext} autoFocus>
                Next Question →
              </button>
            </div>
          )}
        </div>
      );
    }

    function Feedback({ isCorrect, pointsEarned, streakBonus, correctAnswer, onNext }) {
      return (
        <div className={`feedback ${isCorrect ? 'correct' : 'wrong'}`}>
          <div className="feedback-header">
            {isCorrect ? '✓ Correct!' : '✗ Incorrect'}
          </div>
          <div className="feedback-details">
            {isCorrect ? (
              <>
                <div>+{pointsEarned} points (×{streakBonus.toFixed(1)} streak bonus)</div>
              </>
            ) : (
              <>
                <div>Correct answer: {correctAnswer}</div>
              </>
            )}
          </div>
          <button className="next-btn" onClick={onNext}>
            Next Question →
          </button>
        </div>
      );
    }

    // ===================================================================
    // MAIN APP
    // ===================================================================

    function App() {
      const scryfall = useRef(new ScryfallClient());

      // State
      const [cardPool, setCardPool] = useState(null);
      const [loading, setLoading] = useState(null);
      const [error, setError] = useState(null);
      const [currentQuestion, setCurrentQuestion] = useState(null);
      const [showFeedback, setShowFeedback] = useState(false);
      const [isCorrect, setIsCorrect] = useState(false);
      const [selectedIdx, setSelectedIdx] = useState(null);
      const [pointsEarned, setPointsEarned] = useState(0);
      const [streakBonus, setStreakBonus] = useState(1);
      const [streakPopup, setStreakPopup] = useState(null);
      const [questionGenError, setQuestionGenError] = useState(null);
      const [nextQuestionCache, setNextQuestionCache] = useState(null); // Pre-generated next question

      // Filters
      const [activePreset, setActivePreset] = useState('standard');
      const [searchQuery, setSearchQuery] = useState(PRESET_DEFINITIONS.standard.query);
      const [colorFilter, setColorFilter] = useState('');
      const [rarityFilter, setRarityFilter] = useState('');

      // Custom card list
      const [customListText, setCustomListText] = useState(() =>
        loadStorage('card_quiz_custom_list', '')
      );
      const [customListNotFound, setCustomListNotFound] = useState([]);

      // Config - default all showable fields checked
      const getDefaultShownFields = () => {
        return Object.keys(FIELD_CONFIG).filter(key => FIELD_CONFIG[key].canShow);
      };

      const [quizConfig, setQuizConfig] = useState(() =>
        loadStorage(STORAGE_KEYS.CONFIG, {
          shownFields: getDefaultShownFields(),
          askField: 'cardName',
          answerFormat: 'multipleChoice',
          wrongAnswerStrategy: 'pool', // 'pool', 'hierarchical', or 'dynamic'
        })
      );

      // Score
      const [score, setScore] = useState(() =>
        loadStorage(STORAGE_KEYS.SCORE, {
          points: 0,
          questions: 0,
          correct: 0,
          streak: 0,
          bestStreak: 0,
        })
      );

      const [history, setHistory] = useState(() =>
        loadStorage(STORAGE_KEYS.HISTORY, [])
      );

      const [validationErrors, setValidationErrors] = useState([]);

      // Save state
      useEffect(() => { saveStorage(STORAGE_KEYS.SCORE, score); }, [score]);
      useEffect(() => { saveStorage(STORAGE_KEYS.HISTORY, history); }, [history]);
      useEffect(() => { saveStorage(STORAGE_KEYS.CONFIG, quizConfig); }, [quizConfig]);

      // Validate config
      useEffect(() => {
        if (cardPool) {
          const errors = validateQuizConfig(quizConfig, cardPool);
          setValidationErrors(errors);
        } else {
          setValidationErrors([]);
        }
      }, [quizConfig, cardPool]);

      // Initial load
      useEffect(() => {
        loadPreset('standard');
      }, []);

      // Unhighlight preset when search manually modified
      useEffect(() => {
        if (activePreset === 'customList' || Object.keys(PREPOPULATED_LISTS).includes(activePreset)) return;
        const matchingPreset = Object.keys(PRESET_DEFINITIONS).find(
          key => PRESET_DEFINITIONS[key].query === searchQuery
        );
        if (!matchingPreset && activePreset) {
          setActivePreset(null);
        }
      }, [searchQuery]);

      // Auto-search when searchQuery changes (debounced)
      useEffect(() => {
        if (!cardPool) return;
        if (activePreset === 'customList' || Object.keys(PREPOPULATED_LISTS).includes(activePreset)) return;

        const timer = setTimeout(() => {
          handleSearch(searchQuery);
        }, 800);

        return () => clearTimeout(timer);
      }, [searchQuery]);

      // Invalidate cache when config changes that affect question generation
      useEffect(() => {
        setNextQuestionCache(null);
      }, [quizConfig.askField, quizConfig.answerFormat, quizConfig.wrongAnswerStrategy]);

      // Auto-regenerate question only when askField, answerFormat, or pool changes
      // NOTE: shownFields changes should NOT trigger new question (just show/hide fields on same card)
      useEffect(() => {
        if (!cardPool) return;
        if (showFeedback) return;

        nextQuestion();
      }, [cardPool, quizConfig.askField, quizConfig.answerFormat, showFeedback]);

      const loadPreset = async (presetKey) => {
        setLoading(presetKey);
        setError(null);

        try {
          const cards = await scryfall.current.fetchPresetPool(presetKey);
          setCardPool(cards);
          setActivePreset(presetKey);
          setSearchQuery(PRESET_DEFINITIONS[presetKey].query);
        } catch (err) {
          console.error(err);
          setError(`Failed to load ${presetKey}: ${err.message}`);
        } finally {
          setLoading(null);
        }
      };

      const loadCustomList = async () => {
        const names = customListText
          .split('\n')
          .map(l => l.trim())
          .filter(l => l.length > 0);

        if (names.length === 0) return;

        // Dedupe (case-insensitive)
        const seen = new Set();
        const uniqueNames = names.filter(n => {
          const key = n.toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        setLoading('customList');
        setError(null);
        setCustomListNotFound([]);

        try {
          const { found, notFound } = await scryfall.current.fetchByNames(uniqueNames);
          setCustomListNotFound(notFound);

          if (found.length === 0) {
            setError('No cards found. Check the card names and try again.');
            return;
          }

          setCardPool(found);
          setActivePreset('customList');
          saveStorage('card_quiz_custom_list', customListText);
        } catch (err) {
          console.error(err);
          setError(`Failed to load card list: ${err.message}`);
        } finally {
          setLoading(null);
        }
      };

      const loadPrepopulatedList = async (listKey) => {
        const list = PREPOPULATED_LISTS[listKey];
        if (!list) return;

        setLoading(listKey);
        setError(null);
        setCustomListNotFound([]);

        try {
          const { found, notFound } = await scryfall.current.fetchByNames(list.cards);
          setCustomListNotFound(notFound);

          if (found.length === 0) {
            setError(`No cards found from ${list.label}`);
            return;
          }

          setCardPool(found);
          setActivePreset(listKey);
          // Populate textarea with the list
          setCustomListText(list.cards.join('\n'));
        } catch (err) {
          console.error(err);
          setError(`Failed to load ${list.label}: ${err.message}`);
        } finally {
          setLoading(null);
        }
      };

      const handlePresetSelect = (key) => {
        if (key === 'customList') {
          setActivePreset('customList');
          // Don't auto-load — user needs to click "Load Cards"
          return;
        }
        if (Object.keys(PREPOPULATED_LISTS).includes(key)) {
          setActivePreset(key);
          // Don't auto-load — user needs to click "Load Prepopulated List"
          return;
        }
        loadPreset(key);
      };

      const handleSearch = async (query) => {
        if (!query.trim()) return;

        setLoading('search');
        setError(null);

        try {
          const cards = await scryfall.current.fetchByQuery(query, 100);
          setCardPool(cards);
        } catch (err) {
          console.error(err);
          setError(`Search failed: ${err.message}`);
        } finally {
          setLoading(null);
        }
      };

      // Pre-generate next question in background
      const preGenerateNextQuestion = useCallback(async () => {
        if (!cardPool || validationErrors.length > 0) return;

        try {
          const q = await generateCustomQuestion(cardPool, quizConfig, scryfall.current);
          if (q) {
            setNextQuestionCache(q);
          }
        } catch (err) {
          console.error('Failed to pre-generate question:', err);
        }
      }, [cardPool, quizConfig, validationErrors]);

      const nextQuestion = useCallback(async () => {
        if (!cardPool) return;

        setQuestionGenError(null);

        // Use cached question if available, but only if it matches current config
        let q = nextQuestionCache;
        if (q && (q.askField !== quizConfig.askField || q.answerFormat !== quizConfig.answerFormat)) {
          q = null; // Cache is stale (config changed since pre-generation)
        }

        // If no valid cache, generate now
        if (!q && validationErrors.length === 0) {
          q = await generateCustomQuestion(cardPool, quizConfig, scryfall.current);
        }

        if (!q) {
          setQuestionGenError('Unable to generate question with current settings. Try adjusting filters, answer format, or field selections.');
          setCurrentQuestion(null);
          setNextQuestionCache(null);
          return;
        }

        setCurrentQuestion(q);
        setSelectedIdx(null);
        setShowFeedback(false);
        setIsCorrect(false);
        setPointsEarned(0);
        setStreakBonus(1);

        // Clear cache and start pre-generating next question
        setNextQuestionCache(null);
        preGenerateNextQuestion();
      }, [cardPool, quizConfig, validationErrors, nextQuestionCache, preGenerateNextQuestion]);

      const handleAnswer = useCallback((correct, userAnswer) => {
        const streakMult = score.streak >= 10 ? 3 : score.streak >= 5 ? 2 : score.streak >= 3 ? 1.5 : 1;

        let difficultyMult = 1;
        if (currentQuestion?.difficulty !== undefined) {
          difficultyMult = DIFFICULTY_WEIGHTS[currentQuestion.difficulty] || 1;
        }

        const basePoints = correct ? 100 : 0;
        const earned = Math.round(basePoints * streakMult * difficultyMult);
        const newStreak = correct ? score.streak + 1 : 0;
        const bestStreak = Math.max(score.bestStreak, newStreak);

        if (correct && (newStreak === 5 || newStreak === 10 || newStreak === 15 || newStreak === 20 || newStreak === 25)) {
          setStreakPopup(newStreak);
          setTimeout(() => setStreakPopup(null), 900);
        }

        setIsCorrect(correct);
        setPointsEarned(earned);
        setStreakBonus(streakMult);
        setShowFeedback(true);

        if (currentQuestion.answerFormat === 'multipleChoice') {
          const idx = currentQuestion.choices.findIndex(c => c === userAnswer);
          setSelectedIdx(idx);
        }

        setScore({
          points: score.points + earned,
          questions: score.questions + 1,
          correct: score.correct + (correct ? 1 : 0),
          streak: newStreak,
          bestStreak,
        });

        setHistory(prev => [...prev, {
          type: currentQuestion.type,
          cardName: currentQuestion.card.name,
          correct,
          userAnswer: userAnswer || '',
          correctAnswer: currentQuestion.correctAnswer,
          timestamp: new Date().toISOString(),
        }]);
      }, [score, currentQuestion]);

      const accuracy = score.questions > 0 ? Math.round((score.correct / score.questions) * 100) : 0;

      return (
        <div className="app-container">
          <div className="header">
            <h1>MTG Card Knowledge Quiz</h1>
            <div className="subtitle">Custom Mode Only — v2.10.0 (2026-02-18)</div>
            <div className="api-badge">Powered by Scryfall API</div>
          </div>

          <div className="score-bar">
            <div className="score-item">
              <div className="score-label">Score</div>
              <div className="score-value">{score.points}</div>
            </div>
            <div className="score-item">
              <div className="score-label">Correct</div>
              <div className="score-value">{score.correct}/{score.questions}</div>
            </div>
            <div className="score-item">
              <div className="score-label">Streak</div>
              <div className="score-value streak">{score.streak}</div>
            </div>
            <div className="score-item">
              <div className="score-label">Accuracy</div>
              <div className="score-value accuracy">{accuracy}%</div>
            </div>
          </div>

          <PresetSelector
            activePreset={activePreset}
            onSelect={handlePresetSelect}
            loading={loading}
          />

          {activePreset === 'customList' || Object.keys(PREPOPULATED_LISTS).includes(activePreset) ? (
            <CustomListInput
              value={customListText}
              onChange={setCustomListText}
              onLoad={loadCustomList}
              onLoadPrepopulated={loadPrepopulatedList}
              loading={loading === activePreset}
              notFound={customListNotFound}
              activePreset={activePreset}
            />
          ) : (
            <>
              <SearchField
                value={searchQuery}
                onChange={setSearchQuery}
                onSearch={handleSearch}
              />

              <FilterBar
                colorFilter={colorFilter}
                rarityFilter={rarityFilter}
                onColorChange={setColorFilter}
                onRarityChange={setRarityFilter}
              />
            </>
          )}

          {cardPool && (
            <ConfigPanel
              config={quizConfig}
              onConfigChange={setQuizConfig}
              cardPool={cardPool}
            />
          )}

          {loading && (
            <div className="loading-container">
              <div className="spinner" />
              <div>Loading cards...</div>
            </div>
          )}

          {error && (
            <div className="error-container">
              <div className="error-title">Error</div>
              <div className="error-message">{error}</div>
            </div>
          )}

          {questionGenError && (
            <div className="error-container">
              <div className="error-title">Cannot Generate Question</div>
              <div className="error-message">{questionGenError}</div>
            </div>
          )}

          {currentQuestion && !loading && (
            <>
              <QuestionDisplay
                question={currentQuestion}
                onAnswer={handleAnswer}
                showFeedback={showFeedback}
                isCorrect={isCorrect}
                selectedIdx={selectedIdx}
                pointsEarned={pointsEarned}
                streakBonus={streakBonus}
                onNext={nextQuestion}
                liveShownFields={quizConfig.shownFields}
              />
            </>
          )}

          {streakPopup && (
            <div className="streak-popup">
              {streakPopup} STREAK!
            </div>
          )}
        </div>
      );
    }

    // ===================================================================
    // RENDER
    // ===================================================================

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
