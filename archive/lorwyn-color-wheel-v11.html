<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lorwyn Eclipsed - Color Wheel Preview</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
/**
 * Lorwyn Eclipsed Draft Archetypes - Color Wheel Visualization
 * v11 React - Color node hover popups
 *
 * INSTRUCTIONS FOR FUTURE EDITORS:
 * When making changes, please:
 * 1. Save as a NEW file with incremented version (v11 -> v11.1 -> v11.2, or v12, etc.)
 * 2. Update the version in the page subtitle in the new file
 * 3. Add changelog entry at TOP of changelog with format:
 *    vX.X (YYYY-MM-DD, HH:MM UTC) - [Model Name] - Description
 * 4. Include timestamp (UTC), model used, and detailed description
 * 5. Never overwrite previous versions - keep all iterations
 *
 * CHANGELOG:
 * v11   (2026-01-13, ~14:00 UTC) - [Claude Sonnet 4.5] - Changed color nodes to show popup on hover instead of direct click
 *                                                       - Added color descriptions with Scryfall links in popup
 *                                                       - Color popups include brief description of color's role in the set
 * v10.2 (2026-01-13, ~13:45 UTC) - [Claude Sonnet 4.5] - Fixed info panel positioning (now uses fixed positioning with z-index)
 *                    - Added separate "Exactly XX" and "All [Type]s" Scryfall links
 *                    - Made color nodes clickable to search for that color on Scryfall
 *                    - Added sources & citations section at bottom of page
 *                    - Clarified that "Exactly XX" searches for cards with exactly those colors
 * v10.1 (2026-01-13) - Added 800ms delay before info panel disappears (time to click link)
 *                    - Added always-visible archetype reference table for mobile users
 * v10   (2026-01-13) - Added clickable Scryfall links to view all cards for each archetype
 *                    - Updated archetype details with official strategy information
 * v9    (2026-01-13) - Added interactive hover functionality with info panel
 *                    - Added highlight effects on nodes, edges, and labels
 *                    - Added smooth CSS transitions for all interactive elements
 * v8    (earlier)   - Port of Python de-overlap algorithm to React
 *                    - Iterative collision detection for label positioning
 *                    - Smart color rules for background/text readability
 */

const { useState, useEffect, useRef } = React;

// ---------------- Configuration ----------------
const CONFIG = {
  width: 700,
  height: 700,
  cx: 350,
  cy: 330,
  radius: 180,
  nodeRadius: 30,
  edgeWidth: 5,
  boxW: 95,
  boxH: 58,
  fontSize: 12,
  iterMax: 240,
  pushStep: 6,
};

// ---------------- Base colors ----------------
const baseHex = {
  W: "#FFFFFF",
  U: "#3366FF",
  B: "#000000",
  R: "#FF3333",
  G: "#2ECC40",
};

// ---------------- Color Descriptions ----------------
const colorDescriptions = {
  W: {
    name: "White",
    description: "Kithkin tribal synergies and go-wide strategies. Features Merfolk with tap triggers and persist creatures for resilience."
  },
  U: {
    name: "Blue",
    description: "Flash creatures (Faeries and Merfolk) for instant-speed trickery. Supports Elementals and enables vivid splashing with color fixing."
  },
  B: {
    name: "Black",
    description: "Graveyard value with Elves and recursion effects. Goblins with blight and sacrifice synergies. Persist creatures for resilient threats."
  },
  R: {
    name: "Red",
    description: "Aggressive Goblins with sacrifice payoffs. Big Elementals rewarding 4+ CMC spells. Vivid beatdown strategies leveraging color diversity."
  },
  G: {
    name: "Green",
    description: "Elf tribal with graveyard synergies. Kithkin go-wide tokens. Vivid ramp strategies that enable splashing and big threats."
  }
};

// ---------------- Lorwyn Eclipsed Archetypes ----------------
const labels = {
  WU: { text: "*Merfolk", sub: "Tap triggers", details: "Tricksy Merfolk disrupt opponents and accrue value over time. Key Merfolk have abilities that trigger when tapped. Convoke spells let you trigger these abilities without endangering creatures in combat." },
  UB: { text: "Flash", sub: "Trickery", details: "Play on your opponent's turn with flash creatures (mostly Faeries) and instants. This archetype rewards trickery and reactive play, ambushing attackers and controlling tempo through surprise." },
  BR: { text: "*Goblins", sub: "Blight & sacrifice", details: "Rambunctious Goblins combine with the blight mechanic. Goblins trigger powerful abilities when they die, rewarding aggressive sacrifice strategies and death triggers for overwhelming value." },
  RG: { text: "Vivid", sub: "Beatdown", details: "Vivid abilities care about the number of colors among your permanents. Thanks to hybrid mana, even 2-color decks can achieve all five colors. Play efficient beaters and leverage color diversity for bonuses." },
  GW: { text: "*Kithkin", sub: "Go-wide tokens", details: "One of five main typal archetypes. Swarm the board with Kithkin tokens and strengthen them with anthem effects and team buffs for an overwhelming board presence." },
  WB: { text: "Persist", sub: "Recursion", details: "Creatures with persist keep coming back with -1/-1 counters. Layer counter removal effects for repeated value and grind out opponents with resilient threats." },
  UR: { text: "*Elementals", sub: "Big spells 4+", details: "One of five main typal archetypes. Blue-red Elementals represent the four elements and reward casting big spells (CMC 4+). Can enable vivid for 3+ colors and splash cards effectively. Evoke for tempo." },
  BG: { text: "*Elves", sub: "Graveyard value", details: "One of five main typal archetypes. Elves fuel your graveyard and convert it into advantage. Recursion effects and death triggers create a value engine that snowballs over the game." },
  RW: { text: "Giants", sub: "Aggro", details: "Aggressive curve with high-power creatures. Note: Few Giants in this set mean tribal synergies may underperform unless paired with changelings. Focus on the aggressive beatdown plan." },
  GU: { text: "Vivid", sub: "Ramp", details: "Vivid cares about color diversity among your permanents. Ramp into big threats while accumulating multiple colors. Hybrid mana and color fixing enable splashing powerful cards for late-game advantage." },
};

// ---------------- Color helpers ----------------
const hexToRgb = (h) => {
  const hex = h.replace('#', '');
  return [
    parseInt(hex.substring(0, 2), 16),
    parseInt(hex.substring(2, 4), 16),
    parseInt(hex.substring(4, 6), 16),
  ];
};

const rgbToHex = (r, g, b) =>
  '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');

const darken = (h, amt = 0.4) => {
  const [r, g, b] = hexToRgb(h);
  return rgbToHex(r * (1 - amt), g * (1 - amt), b * (1 - amt));
};

const blend = (u, v) => {
  const [r1, g1, b1] = hexToRgb(baseHex[u]);
  const [r2, g2, b2] = hexToRgb(baseHex[v]);
  return rgbToHex((r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2);
};

const relLum = (h) => {
  const [r, g, b] = hexToRgb(h).map(x => x / 255);
  const f = (c) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4));
  return 0.2126 * f(r) + 0.7152 * f(g) + 0.0722 * f(b);
};

const contrastRatio = (bg, fg) => {
  const [L1, L2] = [relLum(bg), relLum(fg)].sort((a, b) => b - a);
  return (L1 + 0.05) / (L2 + 0.05);
};

const getLabelColors = (u, v) => {
  let bg, fg;
  if (u === 'B' || v === 'B') {
    bg = '#000000';
    const partner = u === 'B' ? v : u;
    fg = partner === 'W' ? '#FFFFFF' : baseHex[partner];
  } else if (u === 'W' || v === 'W') {
    const partner = u === 'W' ? v : u;
    bg = darken(baseHex[partner], 0.4);
    fg = '#FFFFFF';
  } else {
    bg = darken(baseHex[u], 0.4);
    fg = baseHex[v];
    if (contrastRatio(bg, fg) < 4.5) {
      const [r, g, b] = hexToRgb(fg);
      fg = rgbToHex(Math.min(r + 140, 255), Math.min(g + 140, 255), Math.min(b + 140, 255));
    }
  }
  return { bg, fg };
};

// ---------------- Geometry ----------------
const colorOrder = ['W', 'U', 'B', 'R', 'G'];

const getNodePos = (index) => {
  const angle = (index * 72 - 90) * (Math.PI / 180);
  return {
    x: CONFIG.cx + CONFIG.radius * Math.cos(angle),
    y: CONFIG.cy + CONFIG.radius * Math.sin(angle),
  };
};

const nodePositions = colorOrder.map((_, i) => getNodePos(i));

// All edges (pairs)
const edges = Object.keys(labels).map(pair => ({
  u: pair[0],
  v: pair[1],
  uIdx: colorOrder.indexOf(pair[0]),
  vIdx: colorOrder.indexOf(pair[1]),
}));

// Calculate visible midpoint and normal
const getEdgeGeometry = (uIdx, vIdx) => {
  const p1 = nodePositions[uIdx];
  const p2 = nodePositions[vIdx];
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const L = Math.hypot(dx, dy);
  const ux = dx / L;
  const uy = dy / L;

  const x = (p1.x + ux * CONFIG.nodeRadius + p2.x - ux * CONFIG.nodeRadius) / 2;
  const y = (p1.y + uy * CONFIG.nodeRadius + p2.y - uy * CONFIG.nodeRadius) / 2;

  const tx = ux, ty = uy;
  const nx = -uy, ny = ux;

  return { x, y, tx, ty, nx, ny };
};

// Bounding box
const getBbox = (cx, cy) => ({
  x1: cx - CONFIG.boxW / 2,
  x2: cx + CONFIG.boxW / 2,
  y1: cy - CONFIG.boxH / 2,
  y2: cy + CONFIG.boxH / 2,
});

// Overlap detection
const isOverlap = (b1, b2, margin = 2) => {
  return !(b1.x2 + margin < b2.x1 || b2.x2 + margin < b1.x1 ||
           b1.y2 + margin < b2.y1 || b2.y2 + margin < b1.y1);
};

// ---------------- De-overlap Algorithm ----------------
const computeLabelPositions = () => {
  const groups = edges.map(edge => {
    const { x, y, tx, ty, nx, ny } = getEdgeGeometry(edge.uIdx, edge.vIdx);

    const sgn = (x - CONFIG.cx) * nx + (y - CONFIG.cy) * ny > 0 ? 1 : -1;
    const off = sgn * 15;
    const tshift = edge.u < edge.v ? 3 : -3;

    const cx = x + nx * off + tx * tshift;
    const cy = y + ny * off + ty * tshift;

    return {
      ...edge,
      cx,
      cy,
      bbox: getBbox(cx, cy),
    };
  });

  for (let iter = 0; iter < CONFIG.iterMax; iter++) {
    let moved = false;
    for (let i = 0; i < groups.length; i++) {
      for (let j = i + 1; j < groups.length; j++) {
        if (isOverlap(groups[i].bbox, groups[j].bbox)) {
          const dx = groups[i].cx - groups[j].cx;
          const dy = groups[i].cy - groups[j].cy;
          const L = Math.hypot(dx, dy) + 0.001;

          groups[i].cx += (dx / L) * CONFIG.pushStep;
          groups[i].cy += (dy / L) * CONFIG.pushStep;
          groups[j].cx -= (dx / L) * CONFIG.pushStep;
          groups[j].cy -= (dy / L) * CONFIG.pushStep;

          groups[i].bbox = getBbox(groups[i].cx, groups[i].cy);
          groups[j].bbox = getBbox(groups[j].cx, groups[j].cy);
          moved = true;
        }
      }
    }
    if (!moved) break;
  }

  return groups;
};

const labelPositions = computeLabelPositions();

// ---------------- Components ----------------
const ColorNode = ({ color, index, isHighlighted, isDimmed, onHover, onLeave }) => {
  const pos = nodePositions[index];

  return (
    <g
      onMouseEnter={onHover}
      onMouseLeave={onLeave}
      style={{ cursor: 'pointer', transition: 'opacity 0.2s ease' }}
      opacity={isDimmed ? 0.3 : 1}
    >
      {/* Glow */}
      <circle
        cx={pos.x}
        cy={pos.y}
        r={CONFIG.nodeRadius + (isHighlighted ? 12 : 8)}
        fill={isHighlighted ? "#FFD700" : baseHex[color]}
        opacity={isHighlighted ? 0.6 : 0.25}
        style={{ transition: 'all 0.2s ease' }}
      />
      {/* Main circle */}
      <circle
        cx={pos.x}
        cy={pos.y}
        r={CONFIG.nodeRadius}
        fill={baseHex[color]}
        stroke={isHighlighted ? "#FFD700" : "#000000"}
        strokeWidth={isHighlighted ? 4 : 3}
        style={{ transition: 'all 0.2s ease' }}
      />
      {/* Letter */}
      <text
        x={pos.x}
        y={pos.y + 7}
        textAnchor="middle"
        fontSize={CONFIG.nodeRadius * 1.2}
        fontWeight="bold"
        fill={color === 'W' ? '#000000' : '#FFFFFF'}
      >
        {color}
      </text>
    </g>
  );
};

const EdgeLine = ({ edge, isHighlighted, isDimmed }) => {
  const p1 = nodePositions[edge.uIdx];
  const p2 = nodePositions[edge.vIdx];
  return (
    <line
      x1={p1.x}
      y1={p1.y}
      x2={p2.x}
      y2={p2.y}
      stroke={isHighlighted ? "#FFD700" : blend(edge.u, edge.v)}
      strokeWidth={isHighlighted ? CONFIG.edgeWidth + 3 : CONFIG.edgeWidth}
      opacity={isDimmed ? 0.2 : 1}
      style={{ transition: 'all 0.2s ease' }}
    />
  );
};

const LabelBox = ({ group, isHighlighted, isDimmed, onHover, onLeave }) => {
  const code = group.u + group.v;
  const labelData = labels[code] || labels[group.v + group.u];
  const { bg, fg } = getLabelColors(group.u, group.v);
  const edgeColor = blend(group.u, group.v);

  return (
    <g
      onMouseEnter={onHover}
      onMouseLeave={onLeave}
      style={{
        cursor: 'pointer',
        transition: 'all 0.2s ease',
      }}
      opacity={isDimmed ? 0.3 : 1}
      transform={isHighlighted ? `translate(${group.cx}, ${group.cy}) scale(1.08) translate(${-group.cx}, ${-group.cy})` : undefined}
    >
      <rect
        x={group.bbox.x1}
        y={group.bbox.y1}
        width={CONFIG.boxW}
        height={CONFIG.boxH}
        rx={6}
        fill={bg}
        stroke={isHighlighted ? "#FFD700" : edgeColor}
        strokeWidth={isHighlighted ? 3 : 2}
        style={{ transition: 'all 0.2s ease' }}
      />
      <text
        x={group.cx}
        y={group.cy - 12}
        textAnchor="middle"
        fontSize={CONFIG.fontSize}
        fontWeight="bold"
        fill={fg}
      >
        {code}
      </text>
      <text
        x={group.cx}
        y={group.cy + 3}
        textAnchor="middle"
        fontSize={CONFIG.fontSize - 1}
        fill={fg}
      >
        {labelData.text}
      </text>
      <text
        x={group.cx}
        y={group.cy + 17}
        textAnchor="middle"
        fontSize={CONFIG.fontSize - 2}
        fill={fg}
        opacity={0.85}
      >
        {labelData.sub}
      </text>
    </g>
  );
};

const ColorInfoPanel = ({ color, onHover, onLeave }) => {
  if (!color) return null;

  const colorData = colorDescriptions[color];
  const colorMap = { W: 'white', U: 'blue', B: 'black', R: 'red', G: 'green' };
  const scryfallUrl = `https://scryfall.com/search?q=set%3Aecl+color%3D${colorMap[color]}`;

  const bg = baseHex[color];
  const fg = color === 'W' ? '#000000' : '#FFFFFF';

  return (
    <div
      onMouseEnter={onHover}
      onMouseLeave={onLeave}
      style={{
        position: 'fixed',
        bottom: '80px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: bg,
        color: fg,
        padding: '16px 24px',
        borderRadius: '8px',
        border: `3px solid ${color === 'W' ? '#E5E7EB' : darken(bg, 0.3)}`,
        maxWidth: '450px',
        textAlign: 'center',
        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
        transition: 'all 0.2s ease',
        zIndex: 999,
      }}>
      <div style={{ fontWeight: 'bold', fontSize: '1.2rem', marginBottom: '4px' }}>
        {color} — {colorData.name}
      </div>
      <div style={{ fontSize: '0.85rem', lineHeight: '1.4', marginBottom: '12px', opacity: 0.95 }}>
        {colorData.description}
      </div>
      <a
        href={scryfallUrl}
        target="_blank"
        rel="noopener noreferrer"
        style={{
          display: 'inline-block',
          padding: '6px 16px',
          backgroundColor: fg,
          color: bg,
          textDecoration: 'none',
          borderRadius: '4px',
          fontSize: '0.85rem',
          fontWeight: '600',
          transition: 'opacity 0.2s ease',
          opacity: 0.95,
        }}
        onMouseEnter={(e) => e.target.style.opacity = '1'}
        onMouseLeave={(e) => e.target.style.opacity = '0.95'}
      >
        View All {colorData.name} Cards →
      </a>
    </div>
  );
};

const InfoPanel = ({ pair, onHover, onLeave }) => {
  if (!pair) return null;

  const labelData = labels[pair];
  const { bg, fg } = getLabelColors(pair[0], pair[1]);

  // Get type name for typal archetypes
  const getTypeName = (p) => {
    const typeMap = {
      'WU': 'Merfolk',
      'BR': 'Goblin',
      'GW': 'Kithkin',
      'UR': 'Elemental',
      'BG': 'Elf'
    };
    return typeMap[p];
  };

  const typeName = getTypeName(pair);

  // Construct Scryfall search URLs
  const colorSearchUrl = `https://scryfall.com/search?q=set%3Aecl+color%3D${pair}`;
  const typeSearchUrl = typeName ? `https://scryfall.com/search?q=set%3Aecl+type%3A${typeName}` : null;

  return (
    <div
      onMouseEnter={onHover}
      onMouseLeave={onLeave}
      style={{
        position: 'fixed',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: bg,
        color: fg,
        padding: '16px 24px',
        borderRadius: '8px',
        border: `2px solid ${blend(pair[0], pair[1])}`,
        maxWidth: '450px',
        textAlign: 'center',
        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
        transition: 'all 0.2s ease',
        zIndex: 1000,
      }}>
      <div style={{ fontWeight: 'bold', fontSize: '1.2rem', marginBottom: '4px' }}>
        {pair} — {labelData.text}
      </div>
      <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '8px' }}>
        {labelData.sub}
      </div>
      <div style={{ fontSize: '0.85rem', lineHeight: '1.4', marginBottom: '12px' }}>
        {labelData.details}
      </div>
      <div style={{ display: 'flex', gap: '8px', justifyContent: 'center', flexWrap: 'wrap' }}>
        <a
          href={colorSearchUrl}
          target="_blank"
          rel="noopener noreferrer"
          style={{
            display: 'inline-block',
            padding: '6px 16px',
            backgroundColor: fg,
            color: bg,
            textDecoration: 'none',
            borderRadius: '4px',
            fontSize: '0.8rem',
            fontWeight: '600',
            transition: 'opacity 0.2s ease',
            opacity: 0.95,
          }}
          onMouseEnter={(e) => e.target.style.opacity = '1'}
          onMouseLeave={(e) => e.target.style.opacity = '0.95'}
        >
          Exactly {pair} Cards →
        </a>
        {typeSearchUrl && (
          <a
            href={typeSearchUrl}
            target="_blank"
            rel="noopener noreferrer"
            style={{
              display: 'inline-block',
              padding: '6px 16px',
              backgroundColor: fg,
              color: bg,
              textDecoration: 'none',
              borderRadius: '4px',
              fontSize: '0.8rem',
              fontWeight: '600',
              transition: 'opacity 0.2s ease',
              opacity: 0.95,
            }}
            onMouseEnter={(e) => e.target.style.opacity = '1'}
            onMouseLeave={(e) => e.target.style.opacity = '0.95'}
          >
            All {typeName}s →
          </a>
        )}
      </div>
    </div>
  );
};

// ---------------- Main Component ----------------
function LorwynColorWheel() {
  const [hoveredNode, setHoveredNode] = useState(null);
  const [hoveredPair, setHoveredPair] = useState(null);
  const [hoveredColor, setHoveredColor] = useState(null);
  const pairTimeoutRef = useRef(null);
  const colorTimeoutRef = useRef(null);

  const handlePairHover = (pairCode) => {
    if (pairTimeoutRef.current) {
      clearTimeout(pairTimeoutRef.current);
      pairTimeoutRef.current = null;
    }
    setHoveredPair(pairCode);
  };

  const handlePairLeave = () => {
    pairTimeoutRef.current = setTimeout(() => {
      setHoveredPair(null);
    }, 800);
  };

  const handleColorHover = (color) => {
    if (colorTimeoutRef.current) {
      clearTimeout(colorTimeoutRef.current);
      colorTimeoutRef.current = null;
    }
    setHoveredColor(color);
  };

  const handleColorLeave = () => {
    colorTimeoutRef.current = setTimeout(() => {
      setHoveredColor(null);
    }, 800);
  };

  useEffect(() => {
    return () => {
      if (pairTimeoutRef.current) clearTimeout(pairTimeoutRef.current);
      if (colorTimeoutRef.current) clearTimeout(colorTimeoutRef.current);
    };
  }, []);

  const activeColors = hoveredPair ? [hoveredPair[0], hoveredPair[1]] : (hoveredNode ? [hoveredNode] : []);
  const activePair = hoveredPair;

  return (
    <div style={{
      minHeight: '100vh',
      backgroundColor: '#FFFFFF',
      padding: '24px',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      position: 'relative',
    }}>
      {/* Header */}
      <div style={{ textAlign: 'center', marginBottom: '16px' }}>
        <h1 style={{ fontSize: '1.8rem', fontWeight: '700', color: '#111827', margin: '0 0 4px 0' }}>
          Lorwyn Eclipsed
        </h1>
        <p style={{ fontSize: '0.95rem', color: '#6B7280', margin: 0 }}>
          Draft Archetypes Color Wheel (v11 Interactive)
        </p>
      </div>

      {/* SVG Diagram */}
      <svg
        viewBox="80 60 540 580"
        style={{ width: '100%', maxWidth: '700px', height: 'auto', display: 'block', margin: '0 auto' }}
      >
        {/* Edges first (behind nodes) */}
        {edges.map((edge, i) => {
          const pairCode = edge.u + edge.v;
          const isHighlighted = activePair === pairCode;
          const isDimmed = activeColors.length > 0 && !activeColors.includes(edge.u) && !activeColors.includes(edge.v);
          return (
            <EdgeLine
              key={`edge-${i}`}
              edge={edge}
              isHighlighted={isHighlighted}
              isDimmed={isDimmed}
            />
          );
        })}

        {/* Nodes */}
        {colorOrder.map((color, i) => {
          const isHighlighted = activeColors.includes(color) || hoveredColor === color;
          const isDimmed = activeColors.length > 0 && !activeColors.includes(color);
          return (
            <ColorNode
              key={color}
              color={color}
              index={i}
              isHighlighted={isHighlighted}
              isDimmed={isDimmed}
              onHover={() => {
                setHoveredNode(color);
                handleColorHover(color);
              }}
              onLeave={() => {
                setHoveredNode(null);
                handleColorLeave();
              }}
            />
          );
        })}

        {/* Labels (on top) */}
        {labelPositions.map((group, i) => {
          const pairCode = group.u + group.v;
          const isHighlighted = activePair === pairCode ||
            (hoveredNode && (group.u === hoveredNode || group.v === hoveredNode));
          const isDimmed = activeColors.length > 0 && !activeColors.includes(group.u) && !activeColors.includes(group.v);
          return (
            <LabelBox
              key={`label-${i}`}
              group={group}
              isHighlighted={isHighlighted}
              isDimmed={isDimmed}
              onHover={() => handlePairHover(pairCode)}
              onLeave={handlePairLeave}
            />
          );
        })}
      </svg>

      {/* Legend */}
      <div style={{
        display: 'flex',
        gap: '20px',
        flexWrap: 'wrap',
        justifyContent: 'center',
        marginTop: '16px',
        padding: '12px 24px',
        backgroundColor: '#F9FAFB',
        borderRadius: '8px',
        border: '1px solid #E5E7EB',
      }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ fontSize: '0.85rem', color: '#4B5563' }}>* = Typal (gold signpost uncommon)</span>
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ fontSize: '0.85rem', color: '#4B5563' }}>No * = Mechanical (hybrid only)</span>
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <span style={{ fontSize: '0.85rem', color: '#6B7280' }}>Hover for details</span>
        </div>
      </div>

      {/* Color Info Panel */}
      <ColorInfoPanel
        color={hoveredColor}
        onHover={() => handleColorHover(hoveredColor)}
        onLeave={handleColorLeave}
      />

      {/* Info Panel */}
      <InfoPanel
        pair={hoveredPair}
        onHover={() => handlePairHover(hoveredPair)}
        onLeave={handlePairLeave}
      />

      {/* Archetype Reference Table */}
      <div style={{
        marginTop: '32px',
        width: '100%',
        maxWidth: '900px',
      }}>
        <h2 style={{
          fontSize: '1.3rem',
          fontWeight: '600',
          color: '#111827',
          marginBottom: '16px',
          textAlign: 'center',
        }}>
          Complete Archetype Reference
        </h2>
        <div style={{
          display: 'grid',
          gap: '12px',
          gridTemplateColumns: 'repeat(auto-fit, minmax(400px, 1fr))',
        }}>
          {Object.entries(labels).map(([pair, data]) => {
            const { bg, fg } = getLabelColors(pair[0], pair[1]);
            const colorSearchUrl = `https://scryfall.com/search?q=set%3Aecl+color%3D${pair}`;

            const typeMap = {
              'WU': 'Merfolk',
              'BR': 'Goblin',
              'GW': 'Kithkin',
              'UR': 'Elemental',
              'BG': 'Elf'
            };
            const typeName = typeMap[pair];
            const typeSearchUrl = typeName ? `https://scryfall.com/search?q=set%3Aecl+type%3A${typeName}` : null;

            return (
              <div
                key={pair}
                style={{
                  backgroundColor: bg,
                  color: fg,
                  padding: '16px',
                  borderRadius: '8px',
                  border: `2px solid ${blend(pair[0], pair[1])}`,
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                }}
              >
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }}>
                  <div>
                    <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>
                      {pair} — {data.text}
                    </div>
                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginTop: '2px' }}>
                      {data.sub}
                    </div>
                  </div>
                </div>
                <div style={{ fontSize: '0.85rem', lineHeight: '1.5', marginBottom: '10px' }}>
                  {data.details}
                </div>
                <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                  <a
                    href={colorSearchUrl}
                    target="_blank"
                    rel="noopener noreferrer"
                    style={{
                      display: 'inline-block',
                      padding: '4px 12px',
                      backgroundColor: fg,
                      color: bg,
                      textDecoration: 'none',
                      borderRadius: '4px',
                      fontSize: '0.75rem',
                      fontWeight: '600',
                      transition: 'opacity 0.2s ease',
                      opacity: 0.95,
                    }}
                    onMouseEnter={(e) => e.target.style.opacity = '1'}
                    onMouseLeave={(e) => e.target.style.opacity = '0.95'}
                  >
                    Exactly {pair}
                  </a>
                  {typeSearchUrl && (
                    <a
                      href={typeSearchUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      style={{
                        display: 'inline-block',
                        padding: '4px 12px',
                        backgroundColor: fg,
                        color: bg,
                        textDecoration: 'none',
                        borderRadius: '4px',
                        fontSize: '0.75rem',
                        fontWeight: '600',
                        transition: 'opacity 0.2s ease',
                        opacity: 0.95,
                      }}
                      onMouseEnter={(e) => e.target.style.opacity = '1'}
                      onMouseLeave={(e) => e.target.style.opacity = '0.95'}
                    >
                      All {typeName}s
                    </a>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Footer */}
      <p style={{ fontSize: '0.75rem', color: '#9CA3AF', marginTop: '12px', textAlign: 'center' }}>
        Prereleases Jan 16–22, 2026 · Faeries & Giants supported at higher rarities
      </p>

      {/* Citations */}
      <div style={{
        marginTop: '24px',
        padding: '16px',
        backgroundColor: '#F9FAFB',
        borderRadius: '8px',
        border: '1px solid #E5E7EB',
        maxWidth: '900px',
        width: '100%',
      }}>
        <div style={{ fontSize: '0.8rem', color: '#6B7280', lineHeight: '1.6' }}>
          <strong style={{ color: '#374151' }}>Sources & Citations:</strong><br />
          Archetype information sourced from official Wizards of the Coast materials and community resources:<br />
          • <a href="https://magic.wizards.com/en/news/feature/lorwyn-eclipsed-prerelease-guide" target="_blank" rel="noopener noreferrer" style={{ color: '#2563EB', textDecoration: 'none' }}>Lorwyn Eclipsed Prerelease Guide</a> (Wizards of the Coast)<br />
          • <a href="https://draftsim.com/mtg-ecl-limited-set-review/" target="_blank" rel="noopener noreferrer" style={{ color: '#2563EB', textDecoration: 'none' }}>The Ultimate Lorwyn Eclipsed Limited Set Review</a> (Draftsim)<br />
          • <a href="https://draftsim.com/mtg-lorwyn-eclipsed/" target="_blank" rel="noopener noreferrer" style={{ color: '#2563EB', textDecoration: 'none' }}>Lorwyn Eclipsed Spoilers and Set Information</a> (Draftsim)<br />
          <br />
          <strong style={{ color: '#374151' }}>Interactive Features:</strong><br />
          • Hover over any color node (W/U/B/R/G) to see that color's role in the set<br />
          • Hover over archetype labels for detailed strategy and Scryfall links<br />
          • Click "Exactly XX" to see cards that are exactly those two colors<br />
          • Click "All [Type]s" to see all creatures of that type in the set
        </div>
      </div>
    </div>
  );
}

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<LorwynColorWheel />);
  </script>
</body>
</html>
